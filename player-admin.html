<!DOCTYPE html>
<html lang="en">
<head>
    <!-- PWA support -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#3498db">
    <link rel="apple-touch-icon" href="/assets/images/logo11.webp">

    <!-- DNS prefetch and preconnect -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800&display=swap" media="print" onload="this.media='all'" crossorigin>
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800&display=swap"></noscript>
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://assets.mixkit.co">
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="icon" href="assets/images/logo11.webp" type="image/webp">
    <link rel="shortcut icon" href="assets/images/logo11.webp" type="image/webp">
    <link rel="apple-touch-icon" href="/assets/images/logo11.webp">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>R2G Player Admin</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" media="print" onload="this.media='all'" crossorigin>
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"></noscript>
    <link rel="stylesheet" href="css/club-dropdown.css">
    <!-- Load club manager script -->
    <script src="js/club-loader.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e3e3e3;
            margin: 0;
            padding: 0;
        }
        .header {
            background-color: #282828;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            flex-wrap: wrap;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
            color: #fff;
            flex: 1;
            min-width: 200px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .username {
            color: #bada55;
            white-space: nowrap;
        }
        .logout-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
        }
        .container {
            padding: 20px;
            display: flex;
            height: calc(100vh - 70px);
            box-sizing: border-box;
        }
        .player-list {
            flex: 1;
            background-color: #282828;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            max-width: 320px;
            margin-right: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .player-list h2 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .search-box {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #fff;
            box-sizing: border-box;
        }
        .player-item {
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .player-item:hover {
            background-color: #333;
        }
        .player-item.selected {
            background-color: #3f51b5;
        }
        .player-thumbnail {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            margin-right: 10px;
            object-fit: cover;
        }
        .player-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-value {
            color: #bada55;
            font-weight: bold;
            margin-left: 5px;
        }
        .player-editor {
            flex: 3;
            background-color: #282828;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: #fff;
            box-sizing: border-box;
        }
        button {
            padding: 10px 15px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .btn-delete {
            background-color: #f44336;
        }
        .btn-delete:hover {
            background-color: #d32f2f;
        }
        .stats-container {
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 15px;
        }
        .stat-item {
            background-color: #333;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .stat-item:hover {
            background-color: #3a3a3a;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .add-stat-btn {
            background-color: #3f51b5;
            transition: background-color 0.2s;
            padding: 10px 20px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .add-stat-btn:hover {
            background-color: #303f9f;
        }
        .add-stat-btn i {
            font-size: 16px;
        }
        .club-dropdown {
            position: relative;
        }
        .club-search,
        .team-search {
            padding-right: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%23aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>');
            background-repeat: no-repeat;
            background-position: calc(100% - 8px) center;
            background-size: 16px;
        }
        .club-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 0 0 4px 4px;
            z-index: 100;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .club-option {
            padding: 8px 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .club-option:hover {
            background-color: #444;
        }
        .club-logo {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            object-fit: contain;
        }
        .buttons-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .status-message {
            padding: 10px;
            margin-top: 15px;
            border-radius: 4px;
            display: none;
        }
        .status-success {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid #4caf50;
        }
        .status-error {
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }
        .add-player-btn {
            margin: 0 0 15px auto;
            display: block;
        }
        /* Tab system */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #444;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            gap: 5px;
        }
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            transition: all 0.2s ease;
            border-radius: 4px 4px 0 0;
        }
        .tab:hover {
            background-color: #333;
        }
        .tab.active {
            border-bottom: 2px solid #4caf50;
            font-weight: 600;
            background-color: #333;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Team dropdown for stats */
        .team-dropdown {
            position: relative;
        }
        .team-search {
            padding-right: 30px;
        }
        .team-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 0 0 4px 4px;
            z-index: 100;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .team-option {
            padding: 8px 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .team-option:hover {
            background-color: #444;
        }
        .team-logo {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            object-fit: contain;
        }
        
        /* Stats reordering controls */
        .stat-controls {
            display: flex;
            gap: 8px;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .stat-move-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #3f51b5;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }
        
        .stat-move-btn:hover {
            background-color: #303f9f;
            transform: scale(1.05);
        }
        
        .stat-move-btn.btn-delete {
            background-color: #f44336;
        }
        
        .stat-move-btn.btn-delete:hover {
            background-color: #d32f2f;
        }
        
        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .add-stat-btn {
            background-color: #3f51b5;
            transition: background-color 0.2s;
            padding: 10px 20px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .add-stat-btn:hover {
            background-color: #303f9f;
        }
        
        .add-stat-btn i {
            font-size: 16px;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                height: auto;
                padding: 15px;
            }
            
            .player-list {
                max-width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
                max-height: 300px;
            }
            
            .header {
                flex-direction: column;
                padding: 15px;
                text-align: center;
            }
            
            .header h1 {
                margin-bottom: 10px;
                font-size: 22px;
            }
            
            .user-info {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 10px;
            }
            
            .logout-btn, .setup-link {
                margin: 5px;
                padding: 8px 12px;
                font-size: 14px;
                flex: 0 1 auto;
            }

            .batch-save-container {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
            }

            .batch-save-btn {
                margin-left: 0;
                margin-top: 10px;
                text-align: center;
            }
            
            .buttons-container {
                flex-direction: column;
                gap: 15px;
            }
            
            .btn-delete {
                align-self: center;
            }
            
            /* Make tabs more usable on mobile */
            .tabs {
                padding-bottom: 5px;
            }
            
            .tab {
                padding: 10px 15px;
                font-size: 15px;
            }
            
            /* Adjust stat items for mobile */
            .stat-item {
                flex-wrap: wrap;
                padding: 15px;
            }
            
            .stat-item > div {
                width: 100%;
                margin-bottom: 10px;
            }
            
            .stat-controls {
                position: relative;
                transform: none;
                justify-content: flex-end;
                margin-top: 10px;
                right: 0;
            }
            
            /* Adjust form elements for touch */
            button, input, select {
                padding: 14px 16px;
                font-size: 16px; /* Prevents iOS zoom on focus */
                border-radius: 6px;
            }
            
            label {
                font-size: 15px;
                margin-bottom: 8px;
            }

            /* Additional mobile fixes for header */
            #vercel-settings-button {
                margin-left: 0 !important;
                margin-top: 8px;
                width: auto;
            }

            /* Improved button spacing in header */
            .user-info {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 8px;
            }

            .username {
                grid-column: 1 / -1;
                text-align: center;
                margin-bottom: 5px;
            }
        }
        .setup-link {
            margin-left: 10px;
            color: #3498db;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background-color: rgba(52, 152, 219, 0.2);
            border-radius: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .setup-link:hover {
            background-color: rgba(52, 152, 219, 0.3);
            color: #2980b9;
        }
        
        .setup-link i {
            margin-right: 5px;
        }

        .history-container {
            margin-top: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .history-item {
            background-color: #333;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .history-item:hover {
            background-color: #3a3a3a;
            transform: translateY(-2px);
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .history-timestamp {
            color: #aaa;
            font-size: 0.9em;
        }

        .history-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .history-type.transfer {
            background-color: #2196f3;
            color: white;
        }

        .history-type.edit {
            background-color: #4caf50;
            color: white;
        }

        .history-type.stats {
            background-color: #ff9800;
            color: white;
        }

        .history-details {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }

        .history-changes {
            display: flex;
            gap: 20px;
        }

        .history-old, .history-new {
            flex: 1;
        }

        .history-label {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .history-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .history-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 15px;
            background-color: #3f51b5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .history-btn:hover {
            background-color: #303f9f;
        }

        .history-btn.revert {
            background-color: #f44336;
        }

        .history-btn.revert:hover {
            background-color: #d32f2f;
        }

        #history-filter {
            padding: 8px;
            background-color: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
        }
        
        /* Add styles for pending changes indicator and batch save button */
        .batch-save-container {
            display: flex;
            align-items: center;
            margin: 0 20px 10px;
            padding: 12px;
            background-color: rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(255, 193, 7, 0.4);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .batch-save-info {
            flex: 1;
            color: #ffb700;
            min-width: 200px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .batch-save-btn {
            background-color: #ffb700;
            color: #333;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
            transition: background-color 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .batch-save-btn:hover {
            background-color: #ffa000;
        }
        
        .pending-changes-counter {
            display: inline-block;
            background-color: #ff5722;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
            font-weight: bold;
        }
        
        .local-updates-container {
            margin-top: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .update-entry {
            padding: 10px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .update-entry:last-child {
            border-bottom: none;
        }
        
        .update-timestamp {
            color: #aaa;
            font-size: 0.8em;
        }
        
        .update-player {
            font-weight: bold;
            color: #bada55;
        }
        
        .update-type {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .update-type.add {
            background-color: #2ecc71;
            color: white;
        }
        
        .update-type.edit {
            background-color: #3498db;
            color: white;
        }
        
        .update-type.delete {
            background-color: #e74c3c;
            color: white;
        }
        
        .update-controls {
            display: flex;
            gap: 8px;
        }
        
        .update-btn {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
            border: none;
        }
        
        .update-btn.undo {
            background-color: #e74c3c;
            color: white;
        }
        
        .update-btn.details {
            background-color: #7f8c8d;
            color: white;
        }

        /* Setup link styles */
        .setup-link {
            margin-left: 10px;
            color: #3498db;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background-color: rgba(52, 152, 219, 0.2);
            border-radius: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .setup-link:hover {
            background-color: rgba(52, 152, 219, 0.3);
            color: #2980b9;
        }
        
        .setup-link i {
            margin-right: 5px;
        }

        /* Vercel settings button */
        #vercel-settings-button {
            margin-left: 10px;
            background-color: #0070f3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
        }

        #vercel-settings-button i {
            margin-right: 5px;
        }

        /* Media query for tablets/medium size devices */
        @media (max-width: 1024px) {
            .header {
                padding: 15px;
            }

            .header h1 {
                margin-bottom: 10px;
                width: 100%;
                text-align: center;
            }

            .user-info {
                width: 100%;
                justify-content: center;
            }
            
            .setup-link, .logout-btn, #vercel-settings-button {
                flex: 1;
                text-align: center;
                justify-content: center;
                margin: 0 5px;
                font-size: 14px;
            }
        }
    </style>

    <!-- Performance optimized CSS -->
    <link rel="stylesheet" href="css/performance.css" media="print" onload="this.media='all'">
    <noscript><link rel="stylesheet" href="css/performance.css">
    <link rel="stylesheet" href="css/additional-fixes.css"></noscript>

</head>
<body>
    <div class="header">
        <h1>R2G Player Admin Panel</h1>
        <div class="user-info">
            <span>Logged in as: <span class="username" id="logged-user">Admin</span></span>
            <button class="logout-btn" id="logout-btn">Logout</button>
            <a href="token-setup.html" class="setup-link" title="Configure GitHub Token">
                <i class="fas fa-cog"></i> Token Setup
            </a>
            <a href="github-redeploy.html" class="setup-link" title="Redeploy GitHub Changes">
                <i class="fas fa-sync-alt"></i> Redeploy Site
            </a>
            <button id="vercel-settings-button">
                <i class="fas fa-cog"></i> Vercel Settings
            </button>
        </div>
    </div>
    
    <!-- Add after the other buttons in the navigation area, before the container div -->
    <div class="batch-save-container" id="batch-save-container" style="display: none;">
        <div class="batch-save-info">
            <i class="fas fa-exclamation-triangle"></i>
            <span id="pending-changes-text">You have pending changes saved to localStorage.</span>
            <span class="pending-changes-counter" id="pending-changes-count">0</span>
        </div>
        <button class="batch-save-btn" id="push-to-github-btn">
            <i class="fab fa-github"></i> Push All to GitHub
        </button>
        <a href="github-redeploy.html" class="batch-save-btn" style="text-decoration:none; text-align:center; margin-left:5px;">
            <i class="fas fa-sync-alt"></i> Redeploy Site
        </a>
    </div>
    
    <div class="local-updates-container" id="local-updates-container" style="display: none;">
        <div class="update-entry-header" style="padding: 10px; background-color: #333; font-weight: bold; border-bottom: 1px solid #444;">
            Recent Local Changes
        </div>
        <div id="update-entries">
            <!-- Update entries will be added here dynamically -->
        </div>
    </div>
    
    <div class="container">
        <div class="player-list">
            <h2>Players</h2>
            <input type="text" class="search-box" id="player-search" placeholder="Search players...">
            <button class="add-player-btn" id="add-player-btn">+ New Player</button>
            <div id="players-container">
                <!-- Player list items will be added here dynamically -->
            </div>
        </div>
        
        <div class="player-editor" id="player-editor">
            <div class="tabs">
                <div class="tab active" data-tab="basic">Basic Info</div>
                <div class="tab" data-tab="stats">Stats & History</div>
                <div class="tab" data-tab="image">Image</div>
                <div class="tab" data-tab="history">Change History</div>
            </div>
            
            <div class="tab-content active" data-tab="basic">
                <div class="form-group">
                    <label for="player-name">Player Name</label>
                    <input type="text" id="player-name" placeholder="Player name">
                </div>
                
                <div class="form-group">
                    <label for="player-star">Star Rating</label>
                    <select id="player-star">
                        <option value="3-star-standard">3 Star Standard</option>
                        <option value="4-star-standard">4 Star Standard</option>
                        <option value="5-star-standard">5 Star Standard</option>
                        <option value="4-star-legend">4 Star Legend</option>
                        <option value="5-star-legend">5 Star Legend</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="player-level">Level</label>
                    <select id="player-level">
                        <option value="STANDARD">STANDARD</option>
                        <option value="LEGENDARY">LEGENDARY</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="player-club">Club</label>
                    <div class="team-dropdown">
                        <input type="text" id="player-club" placeholder="Search club..." class="team-search">
                        <div id="club-options" class="team-options"></div>
                    </div>
                    <div id="club-preview" class="club-preview"></div>
                </div>
                
                <div class="form-group">
                    <label for="player-position">Position</label>
                    <select id="player-position">
                        <option value="GK">GK</option>
                        <option value="CB">CB</option>
                        <option value="LB">LB</option>
                        <option value="RB">RB</option>
                        <option value="DM">DM</option>
                        <option value="CM">CM</option>
                        <option value="AM">AM</option>
                        <option value="LW">LW</option>
                        <option value="RW">RW</option>
                        <option value="ST">ST</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="player-value">Value (RC)</label>
                    <input type="number" id="player-value" min="1" placeholder="Player value">
                </div>
            </div>
            
            <div class="tab-content" data-tab="stats">
                <h3>Player Stats & History</h3>
                <div class="stats-header">
                    <div>
                        <button id="add-stat-btn" class="add-stat-btn"><i class="fas fa-plus"></i> Add New Stat</button>
                    </div>
                </div>
                <div id="stats-container" class="stats-container">
                    <!-- Stat items will be added here dynamically -->
                </div>
            </div>
            
            <div class="tab-content" data-tab="image">
                <h3>Player Image</h3>
                <div class="form-group">
                    <label for="player-image-path">Image Path</label>
                    <input type="text" id="player-image-path" placeholder="../assets/images/players/...">
                </div>
                <div id="image-preview" style="margin-top: 20px; text-align: center;">
                    <!-- Image preview will be shown here -->
                </div>
            </div>
            
            <div class="tab-content" data-tab="history">
                <h3>Change History</h3>
                <div class="history-controls">
                    <button id="refresh-history" class="history-btn">
                        <i class="fas fa-sync"></i> Refresh
                    </button>
                    <select id="history-filter">
                        <option value="all">All Changes</option>
                        <option value="transfers">Transfers Only</option>
                        <option value="edits">Edits Only</option>
                        <option value="stats">Stats Changes</option>
                    </select>
                </div>
                <div id="history-container" class="history-container">
                    <!-- History items will be added here dynamically -->
                </div>
            </div>
            
            <div class="buttons-container">
                <div>
                    <button id="save-btn">Save Changes</button>
                    <button id="cancel-btn">Cancel</button>
                </div>
                <button id="delete-btn" class="btn-delete">Delete Player</button>
            </div>
            
            <div id="status-message" class="status-message"></div>
        </div>
    </div>

    <!-- Add script tag with placeholder - will be filled in next edit -->
    <script defer src="github-config.js"></script>
    <script>
        // GitHub configuration object
        let githubConfig = null;
        
        // Initialize GitHub configuration
        async function initGitHubConfig() {
            try {
                // First try to get config from global object
                if (typeof window.githubConfig !== 'undefined') {
                    githubConfig = window.githubConfig;
                    console.log('GitHub config loaded from global object');
                    return true;
                }
                    
                // Fallback implementation if github-config.js is not available
                githubConfig = {
                    isConfigured: function() {
                        return !!localStorage.getItem('githubToken');
                    },
                    getToken: function() {
                        return localStorage.getItem('githubToken');
                    },
                    getOwner: function() {
                        return localStorage.getItem('githubOwner') || 'default-owner';
                    },
                    getRepo: function() {
                        return localStorage.getItem('githubRepo') || 'default-repo';
                    },
                    getBranch: function() {
                        return localStorage.getItem('githubBranch') || 'main';
                    },
                    filePath: 'players.json',
                    managerFilePath: 'manager_data.json'
                };
                    
                return githubConfig.isConfigured();
            } catch (error) {
                console.error('Error initializing GitHub config:', error);
                    
                // Create minimal emergency fallback
                githubConfig = {
                    isConfigured: () => false,
                    getToken: () => null,
                    getOwner: () => 'default-owner',
                    getRepo: () => 'default-repo', 
                    getBranch: () => 'main',
                    filePath: 'players.json',
                    managerFilePath: 'manager_data.json'
                };
                    
                return false;
            }
        }
        
        // Authentication check
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading indicator
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = 'Loading...';
            statusElement.className = 'status-message status-success';
            statusElement.style.display = 'block';
            
            // First just check if logged in - do this synchronously for speed
            const isLoggedIn = sessionStorage.getItem('adminLoggedIn');
            if (!isLoggedIn) {
                // Redirect to login page
                window.location.href = 'admin-login.html';
                return;
            }
            
            // Set logged in username immediately
            document.getElementById('logged-user').textContent = sessionStorage.getItem('adminUsername') || 'Admin';
            
            // Initialize GitHub config first
            initGitHubConfig();
            
            // Initialize the admin panel right away to show UI faster
            initAdminPanel().then(() => {
                // Check GitHub config after the UI is already showing
                if (!localStorage.getItem('githubToken')) {
                    const configMessage = document.createElement('div');
                    configMessage.className = 'status-message status-error';
                    configMessage.style.display = 'block';
                    configMessage.textContent = 'GitHub integration not configured. Changes will only be saved in memory.';
                    configMessage.style.marginBottom = '10px';
                    
                    // Add a setup button
                    const setupButton = document.createElement('button');
                    setupButton.textContent = 'Configure GitHub';
                    setupButton.style.marginTop = '5px';
                    setupButton.addEventListener('click', () => {
                        window.location.href = 'token-setup.html';
                    });
                    
                    configMessage.appendChild(setupButton);
                    
                    // Insert at the top of the player editor
                    const playerEditor = document.getElementById('player-editor');
                    playerEditor.insertBefore(configMessage, playerEditor.firstChild);
                }
                
                // No need to check server endpoints since we're focused on GitHub
            });
        });

        // Function to check save endpoints availability (deprecated - we're using GitHub now)
        async function checkSaveEndpoints() {
            console.log('checkSaveEndpoints is deprecated - using direct GitHub connection instead');
            // This function is kept for backward compatibility but does nothing
            return;
        }

        // Fast logout function
        function performLogout() {
            // Clear session data first for immediate response
            sessionStorage.removeItem('adminLoggedIn');
            sessionStorage.removeItem('adminUsername');
            
            // Redirect immediately to login page
            window.location.href = 'admin-login.html';
        }

        // Global variables
        let playersData = [];
        let managerData = null; // Add manager data
        let currentPlayer = null;
        let clubsList = [];
        let isNewPlayer = false;
        let debounceTimer = null;
        
        // Pagination variables
        let currentPage = 1;
        const playersPerPage = 50;
        let filteredPlayers = [];
        let totalPages = 1;

        // Debounce function to improve performance for input events
        function debounce(func, delay = 300) {
            return function(...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // Initialize admin panel
        async function initAdminPanel() {
            try {
                // Start with disabling editor while loading
                toggleEditorState(false);
                
                // Show loading in status element
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = 'Loading player data...';
                statusElement.className = 'status-message status-success';
                statusElement.style.display = 'block';
                
                // Set up event listeners early
                setupEventListeners();
                
                // Load data with a timeout to allow UI to render first
                let loadedData = false;
                
                // Try to load data with preference for files updated by GitHub
                const loadPromise = new Promise(async (resolve) => {
                    try {
                        // First try to load from files - these would be updated by GitHub
                        console.log('Loading data from files (would be updated by GitHub)');
                        try {
                            const playersResponse = await fetch('players.json', {
                                cache: 'no-store',  // Don't use cache
                                headers: { 'Cache-Control': 'no-cache' }
                            });
                            
                            if (playersResponse.ok) {
                                playersData = await playersResponse.json();
                                
                                // Add unique ID to each player if missing
                                playersData = playersData.map((player, index) => ({
                                    ...player,
                                    id: player.id ? Number(player.id) : (index + 1)
                                }));
                                
                                console.log('Players loaded from file:', playersData.length);
                                
                                // Also load manager data from file
                                try {
                                    const managerResponse = await fetch('manager_data.json', {
                                        cache: 'no-store',
                                        headers: { 'Cache-Control': 'no-cache' }
                                    });
                                    if (managerResponse.ok) {
                                        managerData = await managerResponse.json();
                                        console.log('Manager data loaded from file');
                                    }
                                } catch (managerError) {
                                    console.error('Error loading manager data from file:', managerError);
                                }
                                
                                resolve(true);
                                return;
                            }
                        } catch (fileError) {
                            console.error('Error loading data from files:', fileError);
                        }
                        
                        // Fallback: try local server if file loading failed
                        console.log('File loading failed, trying local server as fallback');
                        try {
                            const serverAvailable = await isServerAvailable();
                            if (serverAvailable) {
                                const playersResponse = await fetch('http://localhost:3000/players.json');
                                if (playersResponse.ok) {
                                    playersData = await playersResponse.json();
                                    console.log('Loaded players data from Node.js server (fallback)');
                                    
                                    const managerResponse = await fetch('http://localhost:3000/manager_data.json');
                                    if (managerResponse.ok) {
                                        managerData = await managerResponse.json();
                                        console.log('Loaded manager data from Node.js server (fallback)');
                                    }
                                    
                                    resolve(true);
                                    return;
                                }
                            }
                        } catch (serverError) {
                            console.error('Error loading from server (fallback):', serverError);
                        }
                        
                        throw new Error('Failed to load player data from any source');
                    } catch (error) {
                        console.error('Error loading data:', error);
                        resolve(false);
                    }
                });
                
                // Set timeout for loading
                const timeoutPromise = new Promise(resolve => {
                    setTimeout(() => {
                        if (!loadedData) {
                            statusElement.textContent = 'Still loading... This may take a moment.';
                        }
                        resolve(false);
                    }, 1500);
                });
                
                // Wait for data or timeout
                loadedData = await Promise.race([loadPromise, timeoutPromise]);
                
                // Wait for the actual data if timeout happened first
                if (!loadedData) {
                    loadedData = await loadPromise;
                }
                
                if (!loadedData) {
                    throw new Error('Failed to load players data');
                }
                
                // Extract clubs and populate UI
                extractClubs();
                
                // Reset pagination
                currentPage = 1;
                filteredPlayers = [...playersData];
                totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
                
                // Render players
                populatePlayersList();
                
                // Show data summary
                showStatusMessage(`Loaded ${playersData.length} players. Showing page 1 of ${totalPages}.`, true, 3000);
                
                // Hide loading status if it was success
                if (statusElement.textContent === 'Loading player data...' || 
                    statusElement.textContent === 'Still loading... This may take a moment.') {
                    statusElement.style.display = 'none';
                }
                
                // Return a resolved promise for chaining
                return Promise.resolve();
            } catch (error) {
                showStatusMessage(`Error: ${error.message}`, false);
                console.error('Error initializing admin panel:', error);
                return Promise.resolve(); // Still resolve to continue
            }
        }

        // Helper function to determine if the server is available
        async function isServerAvailable() {
            try {
                // Use AbortController to implement a timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 500);  // 500ms timeout
                
                const response = await fetch('http://localhost:3000/players.json', {
                    method: 'HEAD',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                return response.ok;
            } catch (error) {
                console.log('Server check failed:', error.name);
                return false;
            }
        }

        // Add a new function to specifically check if save-managers endpoint is available (deprecated)
        async function isManagerSaveEndpointAvailable() {
            console.log('isManagerSaveEndpointAvailable is deprecated - using direct GitHub connection instead');
            // Always return false since we're using GitHub directly
            return false;
        }

        // Extract unique clubs from player data
        function extractClubs() {
            // This function is now deprecated - using ClubManager instead
            console.log('Using ClubManager for club data');
            return window.ClubManager.initialize();
        }
        
        // Collect all unique team names from player stats
        function collectTeamNames() {
            // This function is now deprecated - using ClubManager instead
            console.log('Using ClubManager for team data');
        }

        // Populate players list
        function populatePlayersList(searchTerm = '') {
            const container = document.getElementById('players-container');
            container.innerHTML = '';
            
            // Filter players if there's a search term
            const lowerSearchTerm = searchTerm.toLowerCase();
            filteredPlayers = searchTerm 
                ? playersData.filter(player => player.name.toLowerCase().includes(lowerSearchTerm))
                : [...playersData];
            
            // Sort players by value (highest first)
            filteredPlayers.sort((a, b) => {
                // Sort by value (highest first)
                if (b.value !== a.value) {
                    return b.value - a.value;
                }
                // If values are equal, sort alphabetically by name
                return a.name.localeCompare(b.name);
            });
            
            // Calculate total pages
            totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
            
            // Make sure current page is valid
            if (currentPage > totalPages) {
                currentPage = totalPages || 1;
            }
            
            // Get current page players
            const startIndex = (currentPage - 1) * playersPerPage;
            const endIndex = Math.min(startIndex + playersPerPage, filteredPlayers.length);
            const currentPagePlayers = filteredPlayers.slice(startIndex, endIndex);
            
            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Show pagination info
            const paginationInfo = document.createElement('div');
            paginationInfo.className = 'pagination-info';
            paginationInfo.style.fontSize = '12px';
            paginationInfo.style.color = '#aaa';
            paginationInfo.style.margin = '5px 0 10px';
            paginationInfo.style.textAlign = 'center';
            paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredPlayers.length} players`;
            fragment.appendChild(paginationInfo);
            
            // Add players for current page
            currentPagePlayers.forEach(player => {
                const playerElement = document.createElement('div');
                playerElement.className = 'player-item';
                playerElement.dataset.id = player.id;
                
                const img = document.createElement('img');
                img.className = 'player-thumbnail';
                img.src = player.imagePath || player.img || 'https://via.placeholder.com/40';
                img.alt = player.name;
                img.loading = 'lazy'; // Lazy load images
                img.onerror = function() {
                    this.src = 'https://via.placeholder.com/40';
                };
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.textContent = player.name;
                
                const valueSpan = document.createElement('span');
                valueSpan.className = 'player-value';
                valueSpan.textContent = player.value;
                
                playerElement.appendChild(img);
                playerElement.appendChild(nameSpan);
                playerElement.appendChild(valueSpan);
                
                playerElement.addEventListener('click', () => {
                    selectPlayer(player.id);
                });
                
                fragment.appendChild(playerElement);
            });
            
            // Create pagination controls if more than one page
            if (totalPages > 1) {
                const paginationControls = document.createElement('div');
                paginationControls.className = 'pagination-controls';
                paginationControls.style.display = 'flex';
                paginationControls.style.justifyContent = 'center';
                paginationControls.style.marginTop = '15px';
                paginationControls.style.gap = '5px';
                
                const prevButton = document.createElement('button');
                prevButton.innerHTML = '&laquo;';
                prevButton.style.padding = '5px 10px';
                prevButton.style.backgroundColor = '#333';
                prevButton.style.border = '1px solid #444';
                prevButton.style.borderRadius = '4px';
                prevButton.style.color = '#fff';
                prevButton.style.cursor = 'pointer';
                prevButton.disabled = currentPage === 1;
                prevButton.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        populatePlayersList(searchTerm);
                    }
                });
                
                const pageInfo = document.createElement('span');
                pageInfo.textContent = `${currentPage} / ${totalPages}`;
                pageInfo.style.padding = '5px 10px';
                pageInfo.style.backgroundColor = '#333';
                pageInfo.style.border = '1px solid #444';
                pageInfo.style.borderRadius = '4px';
                
                const nextButton = document.createElement('button');
                nextButton.innerHTML = '&raquo;';
                nextButton.style.padding = '5px 10px';
                nextButton.style.backgroundColor = '#333';
                nextButton.style.border = '1px solid #444';
                nextButton.style.borderRadius = '4px';
                nextButton.style.color = '#fff';
                nextButton.style.cursor = 'pointer';
                nextButton.disabled = currentPage === totalPages;
                nextButton.addEventListener('click', () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        populatePlayersList(searchTerm);
                    }
                });
                
                paginationControls.appendChild(prevButton);
                paginationControls.appendChild(pageInfo);
                paginationControls.appendChild(nextButton);
                
                fragment.appendChild(paginationControls);
            }
            
            // Append all elements at once
            container.appendChild(fragment);
        }

        // Setup event listeners
        function setupEventListeners() {
            // Logout button
            document.getElementById('logout-btn').addEventListener('click', performLogout);
            
            // Tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const tabName = tab.dataset.tab;
                    document.querySelector(`.tab-content[data-tab="${tabName}"]`).classList.add('active');
                });
            });
            
            // Player search
            const searchInput = document.getElementById('player-search');
            searchInput.addEventListener('input', debounce(function(e) {
                const searchTerm = e.target.value.toLowerCase();
                currentPage = 1; // Reset to first page on search
                populatePlayersList(searchTerm);
            }, 250));
            
            // Club dropdown in basic info tab
            const clubInput = document.getElementById('player-club');
            const clubOptions = document.getElementById('club-options');
            
            clubInput.addEventListener('focus', async () => {
                // Make sure club data is initialized
                if (!window.ClubManager.initialized) {
                    await window.ClubManager.initialize();
                }
                
                populateTeamOptions(clubOptions, clubInput, '');
                clubOptions.style.display = 'block';
            });
            
            clubInput.addEventListener('input', debounce(async function() {
                // Make sure club data is initialized
                if (!window.ClubManager.initialized) {
                    await window.ClubManager.initialize();
                }
                
                populateTeamOptions(clubOptions, clubInput, this.value);
                clubOptions.style.display = 'block';
            }, 200));
            
            clubInput.addEventListener('blur', function() {
                setTimeout(() => {
                    clubOptions.style.display = 'none';
                }, 150);
            });
            
            // Global click handler for dropdowns (both club and team dropdowns)
            document.addEventListener('click', (e) => {
                // Handle club options dropdown
                if (clubOptions && !clubInput.contains(e.target) && !clubOptions.contains(e.target)) {
                    clubOptions.style.display = 'none';
                }
                
                // Handle all team options dropdowns in stat items
                const teamDropdowns = document.querySelectorAll('.team-dropdown');
                teamDropdowns.forEach(dropdown => {
                    const teamInput = dropdown.querySelector('.team-search');
                    const teamOptions = dropdown.querySelector('.team-options');
                    
                    if (teamInput && teamOptions && !teamInput.contains(e.target) && !teamOptions.contains(e.target)) {
                        teamOptions.style.display = 'none';
                    }
                });
            });
            
            // Add new player button
            document.getElementById('add-player-btn').addEventListener('click', createNewPlayer);
            
            // Save button
            document.getElementById('save-btn').addEventListener('click', savePlayerChanges);
            
            // Cancel button
            document.getElementById('cancel-btn').addEventListener('click', () => {
                if (currentPlayer) {
                    loadPlayerData(currentPlayer.id);
                } else {
                    toggleEditorState(false);
                }
            });
            
            // Delete button
            document.getElementById('delete-btn').addEventListener('click', deletePlayer);
            
            // Add stat buttons (both top and bottom)
            document.getElementById('add-stat-btn').addEventListener('click', () => addStatItem());
            
            // Image path input change
            const imagePathInput = document.getElementById('player-image-path');
            imagePathInput.addEventListener('input', debounce(updateImagePreview, 300));
        }

        // Select player by ID
        function selectPlayer(playerId) {
            // Convert playerId to number to ensure consistent comparison
            playerId = Number(playerId);
            
            // Find the player in the data
            currentPlayer = playersData.find(p => Number(p.id) === playerId);
            
            if (!currentPlayer) {
                console.error("Player not found with ID:", playerId);
                showStatusMessage("Error: Player not found", false);
                return;
            }
            
            // Highlight selected player if it's on the current page
            document.querySelectorAll('.player-item').forEach(item => {
                item.classList.remove('selected');
                if (Number(item.dataset.id) === playerId) {
                    item.classList.add('selected');
                    // Scroll the player into view
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });
            
            // If player is not on current page, try to find and navigate to their page
            const playerIndex = filteredPlayers.findIndex(p => Number(p.id) === playerId);
            if (playerIndex !== -1) {
                const playerPage = Math.floor(playerIndex / playersPerPage) + 1;
                if (playerPage !== currentPage) {
                    currentPage = playerPage;
                    populatePlayersList(document.getElementById('player-search').value);
                    
                    // Re-select the player after page change (small delay to let DOM update)
                    setTimeout(() => {
                        document.querySelectorAll('.player-item').forEach(item => {
                            item.classList.remove('selected');
                            if (Number(item.dataset.id) === playerId) {
                                item.classList.add('selected');
                                item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        });
                    }, 50);
                }
            }
            
            // Load player data
            loadPlayerData(playerId);
            
            // Enable editor
            toggleEditorState(true);
            isNewPlayer = false;
        }

        // Load player data into editor
        function loadPlayerData(playerId) {
            // Convert playerId to number to ensure consistent comparison
            playerId = Number(playerId);
            
            currentPlayer = playersData.find(p => Number(p.id) === playerId);
            if (!currentPlayer) {
                console.error("loadPlayerData: Player not found with ID:", playerId);
                return;
            }
            
            // Basic info tab
            document.getElementById('player-name').value = currentPlayer.name || '';
            document.getElementById('player-star').value = currentPlayer.star || '3-star-standard';
            document.getElementById('player-level').value = currentPlayer.level || 'STANDARD';
            document.getElementById('player-club').value = currentPlayer.club || '';
            document.getElementById('player-position').value = currentPlayer.position || 'ST';
            document.getElementById('player-value').value = currentPlayer.value || '';
            
            // Image tab - also handle stats property correctly
            document.getElementById('player-image-path').value = currentPlayer.imagePath || currentPlayer.img || '';
            updateImagePreview();
            
            // Stats tab
            populateStatsContainer();
        }

        // Toggle editor state (enabled/disabled)
        function toggleEditorState(enabled) {
            const editorInputs = document.querySelectorAll('#player-editor input, #player-editor select, #player-editor button:not(#add-player-btn)');
            editorInputs.forEach(input => {
                input.disabled = !enabled;
            });
            
            document.getElementById('player-editor').style.opacity = enabled ? '1' : '0.7';
            document.getElementById('delete-btn').style.display = isNewPlayer ? 'none' : 'block';
        }

        // Create new player
        function createNewPlayer() {
            isNewPlayer = true;
            
            // Generate a temporary ID (negative to avoid conflicts)
            const tempId = -Date.now();
            
            // Create empty player object
            currentPlayer = {
                id: tempId,
                name: '',
                star: '3-star-standard',
                level: 'STANDARD',
                club: '',
                clubLogo: '',
                position: 'ST',
                value: 1,
                imagePath: '',  // Change from img to imagePath to match the rest of the code
                stats: []
            };
            
            // Deselect all players
            document.querySelectorAll('.player-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Reset form
            document.getElementById('player-name').value = '';
            document.getElementById('player-star').value = '3-star-standard';
            document.getElementById('player-level').value = 'STANDARD';
            document.getElementById('player-club').value = '';
            document.getElementById('player-position').value = 'ST';
            document.getElementById('player-value').value = '1';
            document.getElementById('player-image-path').value = '';
            
            // Clear stats
            document.getElementById('stats-container').innerHTML = '';
            
            // Enable editor
            toggleEditorState(true);
            document.getElementById('delete-btn').style.display = 'none';
            
            // Switch to basic info tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('.tab[data-tab="basic"]').classList.add('active');
            document.querySelector('.tab-content[data-tab="basic"]').classList.add('active');
            
            // Focus on name field
            document.getElementById('player-name').focus();
        }

        // Save player changes
        async function savePlayerChanges() {
            // First give immediate UI feedback that save was clicked
            const saveBtn = document.getElementById('save-btn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            try {
                // Validate required fields
                const playerName = document.getElementById('player-name').value.trim();
                const playerValue = parseInt(document.getElementById('player-value').value);
                
                if (!playerName) {
                    throw new Error('Player name is required');
                }
                
                if (isNaN(playerValue) || playerValue < 1) {
                    throw new Error('Player value must be a positive number');
                }
                
                // Update current player object with form values immediately
                const updatedPlayer = {
                    ...currentPlayer,
                    name: playerName,
                    star: document.getElementById('player-star').value,
                    level: document.getElementById('player-level').value,
                    club: document.getElementById('player-club').value,
                    position: document.getElementById('player-position').value,
                    value: playerValue,
                    imagePath: document.getElementById('player-image-path').value
                };
                
                // Get stats with the correct structure
                const statsElements = document.querySelectorAll('.stat-item');
                updatedPlayer.stats = Array.from(statsElements).map(statElement => {
                    const season = statElement.querySelector('[data-stat-season]').value;
                    const team = statElement.querySelector('[data-stat-team]').value;
                    const value = statElement.querySelector('[data-stat-value]').value;
                    
                    return { 
                        season,
                        team,
                        value
                    };
                });
                
                // Update club logo using ClubManager
                const clubData = window.ClubManager.getClub(updatedPlayer.club);
                if (clubData) {
                    updatedPlayer.clubLogo = clubData.logo;
                }
                
                // Update in memory immediately - don't wait for server
                if (isNewPlayer) {
                    // Find the highest existing ID and increment by 1
                    const maxId = Math.max(...playersData.map(p => p.id), 0);
                    updatedPlayer.id = maxId + 1;
                    playersData.push(updatedPlayer);
                    
                    // Add to filtered players if applicable
                    const searchTerm = document.getElementById('player-search').value.toLowerCase();
                    if (!searchTerm || updatedPlayer.name.toLowerCase().includes(searchTerm)) {
                        // Add to filtered players and re-sort
                        filteredPlayers.push(updatedPlayer);
                        
                        // Navigate to the page with the new player
                        currentPage = Math.ceil(filteredPlayers.length / playersPerPage);
                    }
                } else {
                    // Update existing player
                    const playerIndex = playersData.findIndex(p => Number(p.id) === Number(currentPlayer.id));
                    if (playerIndex !== -1) {
                        playersData[playerIndex] = updatedPlayer;
                        
                        // Update in filtered players if present
                        const filteredIndex = filteredPlayers.findIndex(p => Number(p.id) === Number(currentPlayer.id));
                        if (filteredIndex !== -1) {
                            filteredPlayers[filteredIndex] = updatedPlayer;
                        }
                    } else {
                        throw new Error('Player not found in the database');
                    }
                }
                
                // Update current player reference and reset state
                currentPlayer = updatedPlayer;
                isNewPlayer = false;
                
                // Update players list to show changes immediately
                populatePlayersList(document.getElementById('player-search').value);
                
                // Reselect the current player in the list
                selectPlayer(currentPlayer.id);
                
                // Sync changes to manager data
                if (managerData) {
                    syncPlayerToManagerData(updatedPlayer);
                    console.log('Player data synced to manager data:', managerData);
                } else {
                    console.warn('Manager data not available. Cannot sync player data.');
                }
                
                // Show immediate success message
                showStatusMessage('Player saved in memory. Saving to storage...', true);
                
                // Now try saving to persistence (GitHub or server) in background
                let savedPermanently = false;
                let managerDataSaved = false;
                
                // First priority: GitHub if configured
                const useGithub = localStorage.getItem('githubToken');
                if (useGithub) {
                    try {
                        // Initialize GitHub config if needed
                        if (!githubConfig) {
                            initGitHubConfig();
                        }
                        await saveToGitHub();
                        savedPermanently = true;
                        managerDataSaved = true;
                    } catch (githubError) {
                        console.error('GitHub save failed:', githubError);
                        // Continue to try server save if GitHub fails
                    }
                }
                
                // Second priority: Local server if GitHub failed or not configured
                if (!savedPermanently) {
                    const serverAvailable = await isServerAvailable();
                    if (serverAvailable) {
                        try {
                            // Save updated players data to JSON file using the Node.js server
                            const saveResponse = await fetch('http://localhost:3000/save-players', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(playersData)
                            });
                            
                            if (!saveResponse.ok) {
                                const errorData = await saveResponse.json();
                                throw new Error(errorData.message || 'Failed to save changes');
                            }
                            
                            savedPermanently = true;
                            
                            // Also save manager data if it exists
                            if (managerData) {
                                // Check if manager save endpoint is available
                                const managerSaveAvailable = await isManagerSaveEndpointAvailable();
                                
                                if (managerSaveAvailable) {
                                    try {
                                        const saveManagerResponse = await fetch('http://localhost:3000/save-managers', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify(managerData)
                                        });
                                        
                                        if (saveManagerResponse.ok) {
                                            managerDataSaved = true;
                                            console.log('Manager data saved successfully');
                                        } else {
                                            console.error('Failed to save manager data:', await saveManagerResponse.text());
                                        }
                                    } catch (managerSaveError) {
                                        console.error('Error saving manager data:', managerSaveError);
                                    }
                                } else {
                                    console.warn('Manager save endpoint not available');
                                }
                            }
                            
                            showStatusMessage(managerDataSaved ? 
                                'Changes saved to server!' : 
                                'Player data saved, but manager data could not be saved.', 
                                true);
                        } catch (serverError) {
                            console.error('Server save failed:', serverError);
                        }
                    }
                }
                
                // If neither GitHub nor server saved, show warning
                if (!savedPermanently) {
                    showStatusMessage('Warning: Changes are only in memory. Configure GitHub integration to save permanently.', false);
                }
                
            } catch (error) {
                showStatusMessage(error.message, false);
                console.error('Error saving player changes:', error);
            } finally {
                // Always restore button state
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }

        // Sync player changes to manager data
        function syncPlayerToManagerData(player) {
            console.log('Syncing player to manager data:', player);
            
            if (!managerData) {
                console.error('No manager data object is available');
                return;
            }
            
            // Debug the manager data structure
            if (typeof managerData !== 'object') {
                console.error('Manager data is not an object:', typeof managerData, managerData);
                return;
            }
            
            if (!managerData.managers) {
                console.error('Manager data has no managers property:', managerData);
                // Initialize managers array if it doesn't exist
                managerData.managers = [];
            }
            
            if (!Array.isArray(managerData.managers)) {
                console.error('Manager data has managers property but it is not an array:', typeof managerData.managers, managerData.managers);
                // Convert to array if possible
                if (typeof managerData.managers === 'object' && managerData.managers !== null) {
                    console.log('Attempting to convert managers object to array');
                    const managersArray = Object.values(managerData.managers);
                    managerData.managers = managersArray;
                } else {
                    // Reset to empty array if conversion is not possible
                    managerData.managers = [];
                }
            }
            
            // Validate player object has required fields
            if (!player || !player.name || !player.position || !player.value) {
                console.error('Invalid player data for syncing', player);
                return;
            }
            
            const playerName = player.name;
            const playerPosition = player.position;
            const playerValue = Number(player.value);
            const playerClub = player.club || '';
            
            // Skip sync if no club is assigned to player
            if (!playerClub) {
                console.log(`Player "${playerName}" has no club assigned, skipping manager sync.`);
                return;
            }
            
            console.log(`Syncing player "${playerName}" (${playerPosition}) to club "${playerClub}", value: ${playerValue}`);
            console.log(`Total managers in data: ${managerData.managers.length}`);
            
            const playerContract = "SEASON 8";  
            const playerType = (player.level || 'standard').toLowerCase();
            
            // Calculate a default salary based on player value (5% of value as a rough estimate)
            const playerSalary = (playerValue * 0.05).toFixed(1);
            
            // Check if the player exists in any manager's squad
            let foundInSquad = false;
            let needsTransfer = false;
            let oldManager = null;
            let newManager = null;
            
            // First, find the player's current squad and the target squad
            managerData.managers.forEach((manager, index) => {
                console.log(`Checking manager ${index + 1}/${managerData.managers.length}: ${manager.name || 'unnamed'} (${manager.club || 'no club'})`);
                
                if (!manager.squad || !manager.squad.players || !Array.isArray(manager.squad.players)) {
                    // Initialize squad structure if it doesn't exist
                    console.log(`Initializing squad for manager: ${manager.name || 'unnamed'}`);
                    manager.squad = {
                        total_players: 0,
                        players: []
                    };
                }
                
                // Check if player exists in this manager's squad (case-insensitive name comparison)
                const playerIndex = manager.squad.players.findIndex(p => 
                    p && p.name && p.position && 
                    p.name.toUpperCase() === playerName.toUpperCase() && 
                    p.position === playerPosition
                );
                
                if (playerIndex !== -1) {
                    foundInSquad = true;
                    console.log(`Found player "${playerName}" in squad of ${manager.name} (${manager.club})`);
                    
                    // Check if the club has changed (player transfer needed)
                    if (manager.club !== playerClub) {
                        needsTransfer = true;
                        oldManager = manager;
                        console.log(`Player "${playerName}" found in ${manager.club} but needs transfer to ${playerClub}`);
                    } else {
                        // Same club, just update the player details
                        console.log(`Updating player "${playerName}" in same club (${manager.club})`);
                        manager.squad.players[playerIndex].value = playerValue;
                        
                        // Don't override existing contract and salary if they exist
                        if (!manager.squad.players[playerIndex].contract) {
                            manager.squad.players[playerIndex].contract = playerContract;
                        }
                        if (!manager.squad.players[playerIndex].salary) {
                            manager.squad.players[playerIndex].salary = parseFloat(playerSalary);
                        }
                        if (!manager.squad.players[playerIndex].type) {
                            manager.squad.players[playerIndex].type = playerType;
                        }
                        
                        // Recalculate club total value
                        recalculateManagerTotalValue(manager);
                        console.log(`Updated player "${playerName}" in ${manager.club}'s squad`);
                    }
                }
                
                // Check if this is the target manager for a transfer
                if (manager.club && playerClub && 
                    manager.club.toUpperCase() === playerClub.toUpperCase()) {
                    newManager = manager;
                    console.log(`Found target manager for ${playerClub}: ${manager.name}`);
                }
            });
            
            // If we need to do a transfer but couldn't find the target manager, create one
            if (playerClub && !newManager) {
                console.log(`Creating new manager for club ${playerClub}`);
                newManager = {
                    name: `Manager of ${playerClub}`,
                    club: playerClub,
                    overall_rating: 0,
                    r2g_coin_balance: 0,
                    r2g_token_balance: 0,
                    club_total_value: 0,
                    manager_rating: 0,
                    trophies: 0,
                    awards: 0,
                    squad: {
                        total_players: 0,
                        players: []
                    },
                    star_rating: 3
                };
                managerData.managers.push(newManager);
                console.log(`Created new manager for ${playerClub}`);
            }
            
            // Handle player transfers if needed
            if (needsTransfer && oldManager && newManager) {
                try {
                    console.log(`Processing transfer for "${playerName}" from ${oldManager.club} to ${newManager.club}`);
                    
                    // 1. Remove the player from the old squad
                    const oldPlayerIndex = oldManager.squad.players.findIndex(p => 
                        p.name.toUpperCase() === playerName.toUpperCase() && 
                        p.position === playerPosition
                    );
                    
                    if (oldPlayerIndex !== -1) {
                        // Get player data before removing (to preserve contract info if available)
                        const playerData = oldManager.squad.players[oldPlayerIndex];
                        console.log(`Removing player from ${oldManager.club}, current data:`, playerData);
                        
                        // Remove from old squad
                        oldManager.squad.players.splice(oldPlayerIndex, 1);
                        oldManager.squad.total_players = oldManager.squad.players.length;
                        
                        // 2. Add the player to the new squad with updated info
                        const newPlayerData = {
                            name: playerName,
                            position: playerPosition,
                            value: playerValue,
                            contract: playerData.contract || playerContract,
                            salary: playerData.salary || parseFloat(playerSalary),
                            type: playerData.type || playerType
                        };
                        
                        console.log(`Adding player to ${newManager.club} with data:`, newPlayerData);
                        newManager.squad.players.push(newPlayerData);
                        newManager.squad.total_players = newManager.squad.players.length;
                        
                        // 3. Recalculate both squads' total values
                        recalculateManagerTotalValue(oldManager);
                        recalculateManagerTotalValue(newManager);
                        
                        console.log(`Transferred player "${playerName}" from ${oldManager.club} to ${newManager.club}`);
                        
                        // Add to history
                        addToHistory({
                            type: 'transfer',
                            oldTeam: oldManager.club,
                            newTeam: newManager.club,
                            description: `Transferred ${playerName} from ${oldManager.club} to ${newManager.club}`,
                            revertible: true
                        });
                    }
                } catch (transferError) {
                    console.error(`Error transferring player "${playerName}":`, transferError);
                }
            } else if (!foundInSquad && playerClub && newManager) {
                // Player not found in any squad but has a club assigned - add to the new club
                try {
                    const newPlayerData = {
                        name: playerName,
                        position: playerPosition,
                        value: playerValue,
                        contract: playerContract,
                        salary: parseFloat(playerSalary),
                        type: playerType
                    };
                    
                    console.log(`Adding new player "${playerName}" to ${newManager.club}'s squad`, newPlayerData);
                    
                    // Make sure the squad and players array exist
                    if (!newManager.squad) {
                        newManager.squad = { total_players: 0, players: [] };
                    }
                    if (!newManager.squad.players) {
                        newManager.squad.players = [];
                    }
                    
                    newManager.squad.players.push(newPlayerData);
                    newManager.squad.total_players = newManager.squad.players.length;
                    recalculateManagerTotalValue(newManager);
                    
                    console.log(`Added new player "${playerName}" to ${newManager.club}'s squad`);
                } catch (addError) {
                    console.error(`Error adding player "${playerName}" to squad:`, addError);
                }
            } else if (!foundInSquad && playerClub) {
                // Player has club but manager does not exist yet
                console.log(`Player "${playerName}" has club "${playerClub}" but no matching manager found`);
            } else if (!playerClub) {
                console.log(`Player "${playerName}" has no club assigned`);
            }
            
            // Final check to ensure the manager data is in a valid state
            if (!Array.isArray(managerData.managers)) {
                console.error('Manager data is invalid after sync:', managerData);
            } else {
                console.log(`Manager data after sync: ${managerData.managers.length} managers`);
            }
        }

        // Recalculate manager's club total value
        function recalculateManagerTotalValue(manager) {
            if (!manager) {
                console.error('Cannot recalculate value: No manager provided');
                return;
            }
            
            if (!manager.squad || !manager.squad.players || !Array.isArray(manager.squad.players)) {
                console.log(`Setting up empty squad for ${manager.name || 'manager'}`);
                manager.squad = {
                    total_players: 0,
                    players: []
                };
                manager.club_total_value = 0;
                return;
            }
            
            let totalValue = 0;
            
            try {
                manager.squad.players.forEach(player => {
                    if (player && player.value) {
                        const playerValue = parseInt(player.value) || 0;
                        totalValue += playerValue;
                    }
                });
                
                // Update the manager's club total value
                manager.club_total_value = totalValue;
                manager.squad.total_players = manager.squad.players.length;
                
                console.log(`Recalculated total value for ${manager.name || manager.club || 'manager'}: ${totalValue}`);
            } catch (error) {
                console.error('Error calculating manager total value:', error);
                manager.club_total_value = 0;
            }
        }

        // Delete player
        async function deletePlayer() {
            if (!currentPlayer || isNewPlayer) return;
            
            if (!confirm(`Are you sure you want to delete ${currentPlayer.name}?`)) {
                return;
            }
            
            try {
                // Store player ID for later use
                const playerId = Number(currentPlayer.id);
                const playerName = currentPlayer.name;
                const playerPosition = currentPlayer.position;
                
                // Remove player from main array
                const playerIndex = playersData.findIndex(p => Number(p.id) === playerId);
                if (playerIndex !== -1) {
                    playersData.splice(playerIndex, 1);
                    
                    // Also remove from filtered players if present
                    const filteredIndex = filteredPlayers.findIndex(p => Number(p.id) === playerId);
                    if (filteredIndex !== -1) {
                        filteredPlayers.splice(filteredIndex, 1);
                    }
                    
                    // Remove from manager data if present
                    if (managerData && managerData.managers) {
                        managerData.managers.forEach(manager => {
                            if (manager.squad && manager.squad.players) {
                                const squadIndex = manager.squad.players.findIndex(p => 
                                    p.name.toUpperCase() === playerName.toUpperCase() && 
                                    p.position === playerPosition
                                );
                                
                                if (squadIndex !== -1) {
                                    manager.squad.players.splice(squadIndex, 1);
                                    
                                    // Update player count
                                    manager.squad.total_players = manager.squad.players.length;
                                    
                                    // Recalculate club total value
                                    recalculateManagerTotalValue(manager);
                                    
                                    console.log(`Removed player "${playerName}" from ${manager.name}'s squad`);
                                }
                            }
                        });
                    }
                    
                    // Calculate new total pages
                    totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
                    
                    // Adjust current page if needed
                    if (currentPage > totalPages) {
                        currentPage = totalPages || 1;
                    }
                    
                    // Check if GitHub integration is configured
                    const useGithub = localStorage.getItem('githubToken');
                    
                    if (useGithub) {
                        // Save to GitHub
                        await saveToGitHub();
                    } else {
                        // Try server if available
                        const serverAvailable = await isServerAvailable();
                        
                        if (serverAvailable) {
                            // Save updated data to JSON file using the Node.js server
                            const saveResponse = await fetch('http://localhost:3000/save-players', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(playersData)
                            });
                            
                            if (!saveResponse.ok) {
                                const errorData = await saveResponse.json();
                                throw new Error(errorData.message || 'Failed to save changes');
                            }
                            
                            // Also save manager data if it exists
                            if (managerData) {
                                const saveManagerResponse = await fetch('http://localhost:3000/save-managers', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(managerData)
                                });
                                
                                if (!saveManagerResponse.ok) {
                                    console.error('Failed to save manager data');
                                }
                            }
                        } else {
                            // Server not available, show warning
                            showStatusMessage('Warning: Changes are only in memory. Configure GitHub integration to save permanently.', false);
                        }
                    }
                    
                    // Update players list with current search term
                    populatePlayersList(document.getElementById('player-search').value);
                    
                    // Reset editor
                    currentPlayer = null;
                    toggleEditorState(false);
                    
                    showStatusMessage('Player deleted successfully!', true);
                } else {
                    throw new Error('Player not found in the database');
                }
            } catch (error) {
                showStatusMessage(error.message, false);
                console.error('Error deleting player:', error);
            }
        }

        // Populate stats container
        function populateStatsContainer() {
            const container = document.getElementById('stats-container');
            container.innerHTML = '';
            
            if (!currentPlayer || !currentPlayer.stats || !Array.isArray(currentPlayer.stats)) {
                return;
            }
            
            currentPlayer.stats.forEach(stat => {
                addStatItem(
                    stat.season || '', 
                    stat.team || '', 
                    stat.value || ''
                );
            });
        }

        // Add stat item with the correct fields matching the JSON structure
        function addStatItem(season = '', team = '', statValue = '') {
            const container = document.getElementById('stats-container');
            const statElement = document.createElement('div');
            statElement.className = 'stat-item';
            
            // Create season input
            const seasonInput = document.createElement('input');
            seasonInput.type = 'text';
            seasonInput.value = season;
            seasonInput.placeholder = 'Season (e.g. 6-8)';
            seasonInput.dataset.statSeason = 'true';
            seasonInput.style.flex = '1';
            seasonInput.style.marginRight = '10px';
            
            // Create team input with dropdown
            const teamDropdown = document.createElement('div');
            teamDropdown.className = 'team-dropdown';
            teamDropdown.style.flex = '1.5';
            teamDropdown.style.marginRight = '10px';
            
            const teamInput = document.createElement('input');
            teamInput.type = 'text';
            teamInput.value = team;
            teamInput.placeholder = 'Team';
            teamInput.dataset.statTeam = 'true';
            teamInput.className = 'team-search';
            
            const teamOptions = document.createElement('div');
            teamOptions.className = 'team-options';
            
            teamDropdown.appendChild(teamInput);
            teamDropdown.appendChild(teamOptions);
            
            // Setup team dropdown functionality
            teamInput.addEventListener('focus', async () => {
                // Make sure club data is initialized
                if (!window.ClubManager.initialized) {
                    await window.ClubManager.initialize();
                }
                
                populateTeamOptions(teamOptions, teamInput, '');
                teamOptions.style.display = 'block';
            });
            
            teamInput.addEventListener('input', async function() {
                // Make sure club data is initialized
                if (!window.ClubManager.initialized) {
                    await window.ClubManager.initialize();
                }
                
                populateTeamOptions(teamOptions, teamInput, this.value);
                teamOptions.style.display = 'block';
            });
            
            // Track mouse in dropdown
            let mouseInTeamDropdown = false;
            
            teamOptions.addEventListener('mouseenter', () => {
                mouseInTeamDropdown = true;
            });
            
            teamOptions.addEventListener('mouseleave', () => {
                mouseInTeamDropdown = false;
            });
            
            teamInput.addEventListener('blur', () => {
                // Give more time to select before hiding
                setTimeout(() => {
                    if (!mouseInTeamDropdown) {
                        teamOptions.style.display = 'none';
                    }
                }, 500);
            });
            
            // Create value input
            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.value = statValue;
            valueInput.placeholder = 'Value (e.g. 150 RC)';
            valueInput.dataset.statValue = 'true';
            valueInput.style.flex = '1';
            valueInput.style.marginRight = '10px';
            
            // Create controls for reordering and deletion
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'stat-controls';
            
            // Create move up button
            const moveUpBtn = document.createElement('button');
            moveUpBtn.className = 'stat-move-btn';
            moveUpBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
            moveUpBtn.title = 'Move Up';
            moveUpBtn.addEventListener('click', (e) => {
                e.preventDefault();
                moveStatUp(statElement);
            });
            
            // Create move down button
            const moveDownBtn = document.createElement('button');
            moveDownBtn.className = 'stat-move-btn';
            moveDownBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
            moveDownBtn.title = 'Move Down';
            moveDownBtn.addEventListener('click', (e) => {
                e.preventDefault();
                moveStatDown(statElement);
            });
            
            // Create delete button
            const deleteButton = document.createElement('button');
            deleteButton.className = 'stat-move-btn btn-delete';
            deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
            deleteButton.title = 'Delete Stat';
            deleteButton.addEventListener('click', (e) => {
                e.preventDefault();
                container.removeChild(statElement);
            });
            
            // Add buttons to controls container
            controlsContainer.appendChild(moveUpBtn);
            controlsContainer.appendChild(moveDownBtn);
            controlsContainer.appendChild(deleteButton);
            
            // Add labels above inputs for clarity
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.width = '100%';
            
            // Create header row with labels
            const headerRow = document.createElement('div');
            headerRow.style.display = 'flex';
            headerRow.style.marginBottom = '5px';
            
            const seasonLabel = document.createElement('div');
            seasonLabel.textContent = 'Season';
            seasonLabel.style.flex = '1';
            seasonLabel.style.marginRight = '10px';
            seasonLabel.style.fontSize = '12px';
            
            const teamLabel = document.createElement('div');
            teamLabel.textContent = 'Team';
            teamLabel.style.flex = '1.5';
            teamLabel.style.marginRight = '10px';
            teamLabel.style.fontSize = '12px';
            
            const valueLabel = document.createElement('div');
            valueLabel.textContent = 'Value';
            valueLabel.style.flex = '1';
            valueLabel.style.marginRight = '10px';
            valueLabel.style.fontSize = '12px';
            
            headerRow.appendChild(seasonLabel);
            headerRow.appendChild(teamLabel);
            headerRow.appendChild(valueLabel);
            
            // Create inputs row
            const inputsRow = document.createElement('div');
            inputsRow.style.display = 'flex';
            
            inputsRow.appendChild(seasonInput);
            inputsRow.appendChild(teamDropdown);
            inputsRow.appendChild(valueInput);
            
            wrapper.appendChild(headerRow);
            wrapper.appendChild(inputsRow);
            
            statElement.appendChild(wrapper);
            statElement.appendChild(controlsContainer);
            container.appendChild(statElement);
        }

        // Move stat item up
        function moveStatUp(statElement) {
            const container = document.getElementById('stats-container');
            const prevStat = statElement.previousElementSibling;
            
            if (prevStat) {
                container.insertBefore(statElement, prevStat);
            }
        }
        
        // Move stat item down
        function moveStatDown(statElement) {
            const container = document.getElementById('stats-container');
            const nextStat = statElement.nextElementSibling;
            
            if (nextStat) {
                container.insertBefore(nextStat, statElement);
            }
        }
        
        // Populate team options for stat dropdowns
        function populateTeamOptions(container, inputElement, searchTerm = '') {
            // Use the ClubManager to populate team options
            window.ClubManager.populateClubOptions(container, inputElement, searchTerm, club => {
                // Update any related UI or data after selection
                inputElement.value = club.name;
                container.style.display = 'none';
                
                // If in basic info tab, update club logo preview if it exists
                if (inputElement.id === 'player-club') {
                    const clubLogoPreview = document.getElementById('club-logo-preview');
                    if (clubLogoPreview && club.logo) {
                        clubLogoPreview.src = club.logo;
                        clubLogoPreview.style.display = 'block';
                    }
                    
                    // Create preview if it doesn't exist
                    const clubPreviewContainer = document.getElementById('club-preview');
                    if (clubPreviewContainer && !clubLogoPreview) {
                        const newClubLogoPreview = document.createElement('img');
                        newClubLogoPreview.id = 'club-logo-preview';
                        newClubLogoPreview.className = 'club-logo-preview';
                        newClubLogoPreview.style.maxWidth = '50px';
                        newClubLogoPreview.style.maxHeight = '50px';
                        newClubLogoPreview.style.marginTop = '5px';
                        newClubLogoPreview.src = club.logo;
                        newClubLogoPreview.style.display = 'block';
                        clubPreviewContainer.appendChild(newClubLogoPreview);
                    }
                }
            });
        }

        // Update image preview
        function updateImagePreview() {
            const imagePath = document.getElementById('player-image-path').value;
            const previewContainer = document.getElementById('image-preview');
            
            if (imagePath) {
                const img = document.createElement('img');
                img.src = imagePath;
                img.alt = 'Player image preview';
                img.style.maxWidth = '200px';
                img.style.maxHeight = '200px';
                img.style.border = '2px solid #444';
                img.onerror = function() {
                    previewContainer.innerHTML = '<p style="color: #f44336;">Invalid image path</p>';
                };
                
                previewContainer.innerHTML = '';
                previewContainer.appendChild(img);
            } else {
                previewContainer.innerHTML = '<p>No image path provided</p>';
            }
        }

        // Show status message
        function showStatusMessage(message, isSuccess, duration = 5000) {
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = message;
            statusElement.className = 'status-message';
            statusElement.classList.add(isSuccess ? 'status-success' : 'status-error');
            statusElement.style.display = 'block';
            
            // Hide after duration
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, duration);
        }

        // Save to GitHub
        async function saveToGitHub() {
            try {
                console.log('Starting GitHub save process...');
                
                // Initialize GitHub config if needed
                if (!githubConfig) {
                    console.log('Initializing GitHub config...');
                    initGitHubConfig();
                }
                
                // Check if GitHub integration is configured
                if (!githubConfig.isConfigured()) {
                    console.error('GitHub integration is not configured');
                    throw new Error('GitHub integration is not configured');
                }
                
                // Show saving message
                showStatusMessage('Saving to GitHub...', true);
                
                // Get repository details
                const repoDetails = {
                    owner: githubConfig.getOwner(),
                    repo: githubConfig.getRepo(),
                    path: localStorage.getItem('githubJsonPath') || githubConfig.filePath,
                    branch: githubConfig.getBranch()
                };
                
                console.log('Using repository details:', repoDetails);
                
                let savedPlayers = false;
                let savedManagers = false;
                
                try {
                    // Save players.json
                    console.log('Saving players.json...');
                    const playersResponse = await saveFileToGitHub(playersData, 'players.json', 'Update players from admin panel');
                    savedPlayers = playersResponse.ok;
                    console.log('Players save result:', savedPlayers);
                    
                    // Save manager_data.json if we have manager data
                    if (managerData) {
                        console.log('Saving manager_data.json...');
                        const managersDataFormatted = { managers: managerData.managers || [] };
                        const managersResponse = await saveFileToGitHub(managersDataFormatted, 'manager_data.json', 'Update managers from admin panel');
                        savedManagers = managersResponse.ok;
                        console.log('Managers save result:', savedManagers);
                    } else {
                        console.log('No manager data to save');
                        savedManagers = true; // Consider it successful if there's no manager data
                    }
                    
                    // Only consider it successful if both saves worked (or if manager save wasn't needed)
                    const success = savedPlayers && savedManagers;
                    
                    if (success) {
                        console.log('All files saved successfully to GitHub');
                        // Store the success timestamp
                        localStorage.setItem('lastGitHubPushTimestamp', new Date().toISOString());
                        // Clear pending changes
                        pendingChanges = [];
                        localStorage.removeItem('pendingPlayerChanges');
                        // Update UI
                        updatePendingChangesUI();
                        showStatusMessage('Changes saved to GitHub! The site will update in a few minutes. If changes don\'t appear, use the <a href="github-redeploy.html">Redeploy Site</a> tool.', true);
                    } else {
                        throw new Error('Failed to save all files to GitHub');
                    }
                    
                    return success;
                    
                } catch (error) {
                    console.error('Error during file saves:', error);
                    throw error;
                }
                
            } catch (error) {
                console.error('GitHub save error:', error);
                showStatusMessage(`GitHub Error: ${error.message}`, false);
                return false;
            }
        }

        // Save a file to GitHub
        async function saveFileToGitHub(data, filePath, commitMessage) {
            try {
                console.log(`Starting save for ${filePath}...`);
                
                // Get repository details
                const repoDetails = {
                    owner: githubConfig.getOwner(),
                    repo: githubConfig.getRepo(),
                    path: filePath,
                    branch: githubConfig.getBranch()
                };
                
                // Get the current file to get its SHA
                console.log('Fetching current file info...');
                const fileInfoResponse = await fetch(`https://api.github.com/repos/${repoDetails.owner}/${repoDetails.repo}/contents/${repoDetails.path}?ref=${repoDetails.branch}`, {
                    headers: {
                        'Authorization': `token ${githubConfig.getToken()}`
                    }
                });
                
                let currentSHA = '';
                let fileExists = true;
                
                if (fileInfoResponse.status === 404) {
                    console.log('File does not exist yet, will create it');
                    fileExists = false;
                } else if (!fileInfoResponse.ok) {
                    const errorData = await fileInfoResponse.json();
                    console.error('Error getting file info:', errorData);
                    throw new Error(`GitHub API error: ${errorData.message}`);
                } else {
                    const fileInfo = await fileInfoResponse.json();
                    currentSHA = fileInfo.sha;
                    console.log('Found existing file with SHA:', currentSHA);
                }
                
                // Prepare the content
                const jsonString = JSON.stringify(data, null, 2);
                const content = btoa(unescape(encodeURIComponent(jsonString)));
                
                // Prepare the commit
                const requestBody = {
                    message: `${commitMessage} - ${new Date().toISOString()}`,
                    content: content,
                    branch: repoDetails.branch
                };
                
                if (fileExists) {
                    requestBody.sha = currentSHA;
                }
                
                console.log(`Committing ${filePath}...`);
                const commitResponse = await fetch(`https://api.github.com/repos/${repoDetails.owner}/${repoDetails.repo}/contents/${repoDetails.path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${githubConfig.getToken()}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!commitResponse.ok) {
                    const errorData = await commitResponse.json();
                    console.error(`Failed to commit ${filePath}:`, errorData);
                    throw new Error(`Failed to commit ${filePath}: ${errorData.message}`);
                }
                
                console.log(`Successfully saved ${filePath}`);
                return commitResponse;
                
            } catch (error) {
                console.error(`Error saving ${filePath}:`, error);
                throw error;
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize club data first to ensure it's available
            await window.ClubManager.initialize();
            
            // Load players data
            loadPlayersData();
            
            // Add event listeners
            setupEventListeners();
        });

        // Add to your existing JavaScript
        let changeHistory = [];

        function addToHistory(change) {
            const timestamp = new Date().toISOString();
            changeHistory.unshift({
                timestamp,
                ...change
            });

            // Save to localStorage
            localStorage.setItem('playerChangeHistory', JSON.stringify(changeHistory));
            
            // Update history display if tab is active
            if (document.querySelector('.tab[data-tab="history"]').classList.contains('active')) {
                displayHistory();
            }
        }

        function displayHistory() {
            const container = document.getElementById('history-container');
            const filter = document.getElementById('history-filter').value;
            container.innerHTML = '';

            const filteredHistory = changeHistory.filter(change => {
                if (filter === 'all') return true;
                return change.type === filter;
            });

            filteredHistory.forEach(change => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                const header = document.createElement('div');
                header.className = 'history-header';
                
                const timestamp = new Date(change.timestamp).toLocaleString();
                header.innerHTML = `
                    <div class="history-timestamp">${timestamp}</div>
                    <div class="history-type ${change.type}">${change.type.toUpperCase()}</div>
                `;

                const details = document.createElement('div');
                details.className = 'history-details';
                
                if (change.type === 'transfer') {
                    details.innerHTML = `
                        <div class="history-changes">
                            <div class="history-old">
                                <div class="history-label">From:</div>
                                <div>${change.oldTeam || 'N/A'}</div>
                            </div>
                            <div class="history-new">
                                <div class="history-label">To:</div>
                                <div>${change.newTeam}</div>
                            </div>
                        </div>
                    `;
                } else {
                    details.innerHTML = `
                        <div class="history-changes">
                            <div class="history-old">
                                <div class="history-label">Previous:</div>
                                <pre>${JSON.stringify(change.oldValue, null, 2)}</pre>
                            </div>
                            <div class="history-new">
                                <div class="history-label">New:</div>
                                <pre>${JSON.stringify(change.newValue, null, 2)}</pre>
                            </div>
                        </div>
                    `;
                }

                // Add revert button if change is revertible
                if (change.revertible) {
                    const revertBtn = document.createElement('button');
                    revertBtn.className = 'history-btn revert';
                    revertBtn.innerHTML = '<i class="fas fa-undo"></i> Revert';
                    revertBtn.onclick = () => revertChange(change);
                    details.appendChild(revertBtn);
                }

                historyItem.appendChild(header);
                historyItem.appendChild(details);
                container.appendChild(historyItem);
            });
        }

        function revertChange(change) {
            if (confirm('Are you sure you want to revert this change?')) {
                // Handle revert based on change type
                if (change.type === 'transfer') {
                    // Revert transfer
                    currentPlayer.club = change.oldTeam;
                    document.getElementById('player-club').value = change.oldTeam;
                } else {
                    // Revert other changes
                    Object.assign(currentPlayer, change.oldValue);
                    loadPlayerData(currentPlayer.id);
                }

                // Add revert action to history
                addToHistory({
                    type: 'revert',
                    oldValue: change.newValue,
                    newValue: change.oldValue,
                    description: `Reverted: ${change.description}`,
                    revertible: false
                });

                // Save changes
                savePlayerChanges();
            }
        }

        // Load history from localStorage on init
        document.addEventListener('DOMContentLoaded', () => {
            const savedHistory = localStorage.getItem('playerChangeHistory');
            if (savedHistory) {
                changeHistory = JSON.parse(savedHistory);
            }

            // Add history filter change handler
            document.getElementById('history-filter').addEventListener('change', displayHistory);
            
            // Add refresh button handler
            document.getElementById('refresh-history').addEventListener('click', displayHistory);
        });

        // Add after initAdminPanel function, before isServerAvailable
        // Helper function to repair and standardize manager data format
        function repairManagerData() {
            if (!managerData) {
                console.log('No manager data to repair');
                return false;
            }
            
            let wasRepaired = false;
            
            // Check if managerData is an object
            if (typeof managerData !== 'object' || managerData === null) {
                console.error('Manager data is not an object, initializing empty structure');
                managerData = { managers: [] };
                wasRepaired = true;
                return wasRepaired;
            }
            
            // Fix managers property if missing or not an array
            if (!managerData.managers) {
                console.log('Manager data missing managers property, adding empty array');
                managerData.managers = [];
                wasRepaired = true;
            } else if (!Array.isArray(managerData.managers)) {
                console.log('Manager data managers property is not an array, converting');
                
                // If it's an object with numeric keys, try to convert to array
                if (typeof managerData.managers === 'object' && managerData.managers !== null) {
                    try {
                        const managersArray = Object.values(managerData.managers);
                        managerData.managers = managersArray;
                        wasRepaired = true;
                        console.log('Converted managers object to array');
                    } catch (error) {
                        console.error('Failed to convert managers object to array:', error);
                        managerData.managers = [];
                        wasRepaired = true;
                    }
                } else {
                    managerData.managers = [];
                    wasRepaired = true;
                }
            }
            
            // Verify each manager object has required properties
            managerData.managers.forEach((manager, index) => {
                if (!manager.name) {
                    console.log(`Manager at index ${index} missing name, adding placeholder`);
                    manager.name = `Manager ${index + 1}`;
                    wasRepaired = true;
                }
                
                if (!manager.club) {
                    console.log(`Manager at index ${index} (${manager.name}) missing club, adding placeholder`);
                    manager.club = `Club ${index + 1}`;
                    wasRepaired = true;
                }
                
                // Ensure squad exists and has the right format
                if (!manager.squad) {
                    console.log(`Manager ${manager.name} missing squad, adding empty squad`);
                    manager.squad = { total_players: 0, players: [] };
                    wasRepaired = true;
                } else {
                    if (!manager.squad.players) {
                        console.log(`Manager ${manager.name} squad missing players array, adding empty array`);
                        manager.squad.players = [];
                        wasRepaired = true;
                    } else if (!Array.isArray(manager.squad.players)) {
                        console.log(`Manager ${manager.name} squad players is not an array, converting`);
                        
                        try {
                            if (typeof manager.squad.players === 'object' && manager.squad.players !== null) {
                                manager.squad.players = Object.values(manager.squad.players);
                            } else {
                                manager.squad.players = [];
                            }
                            wasRepaired = true;
                        } catch (error) {
                            console.error(`Error converting players for manager ${manager.name}:`, error);
                            manager.squad.players = [];
                            wasRepaired = true;
                        }
                    }
                    
                    // Update total_players to match array length
                    if (manager.squad.total_players !== manager.squad.players.length) {
                        console.log(`Manager ${manager.name} total_players (${manager.squad.total_players}) doesn't match players array length (${manager.squad.players.length}), updating`);
                        manager.squad.total_players = manager.squad.players.length;
                        wasRepaired = true;
                    }
                    
                    // Recalculate club value based on players
                    recalculateManagerTotalValue(manager);
                }
            });
            
            return wasRepaired;
        }

        // Modify initAdminPanel to call repairManagerData after loading manager data
        async function initAdminPanel() {
            try {
                // Start with disabling editor while loading
                toggleEditorState(false);
                
                // Show loading in status element
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = 'Loading player data...';
                statusElement.className = 'status-message status-success';
                statusElement.style.display = 'block';
                
                // Set up event listeners early
                setupEventListeners();
                
                // Load data with a timeout to allow UI to render first
                let loadedData = false;
                
                // Try to load data with preference for files updated by GitHub
                const loadPromise = new Promise(async (resolve) => {
                    try {
                        // First try to load from files - these would be updated by GitHub
                        console.log('Loading data from files (would be updated by GitHub)');
                        try {
                            const playersResponse = await fetch('players.json', {
                                cache: 'no-store',  // Don't use cache
                                headers: { 'Cache-Control': 'no-cache' }
                            });
                            
                            if (playersResponse.ok) {
                                playersData = await playersResponse.json();
                                
                                // Add unique ID to each player if missing
                                playersData = playersData.map((player, index) => ({
                                    ...player,
                                    id: player.id ? Number(player.id) : (index + 1)
                                }));
                                
                                console.log('Players loaded from file:', playersData.length);
                                
                                // Also load manager data from file
                                try {
                                    const managerResponse = await fetch('manager_data.json', {
                                        cache: 'no-store',
                                        headers: { 'Cache-Control': 'no-cache' }
                                    });
                                    if (managerResponse.ok) {
                                        managerData = await managerResponse.json();
                                        console.log('Manager data loaded from file');
                                    }
                                } catch (managerError) {
                                    console.error('Error loading manager data from file:', managerError);
                                }
                                
                                resolve(true);
                                return;
                            }
                        } catch (fileError) {
                            console.error('Error loading data from files:', fileError);
                        }
                        
                        // Fallback: try local server if file loading failed
                        console.log('File loading failed, trying local server as fallback');
                        try {
                            const serverAvailable = await isServerAvailable();
                            if (serverAvailable) {
                                const playersResponse = await fetch('http://localhost:3000/players.json');
                                if (playersResponse.ok) {
                                    playersData = await playersResponse.json();
                                    console.log('Loaded players data from Node.js server (fallback)');
                                    
                                    const managerResponse = await fetch('http://localhost:3000/manager_data.json');
                                    if (managerResponse.ok) {
                                        managerData = await managerResponse.json();
                                        console.log('Loaded manager data from Node.js server (fallback)');
                                    }
                                    
                                    resolve(true);
                                    return;
                                }
                            }
                        } catch (serverError) {
                            console.error('Error loading from server (fallback):', serverError);
                        }
                        
                        throw new Error('Failed to load player data from any source');
                    } catch (error) {
                        console.error('Error loading data:', error);
                        resolve(false);
                    }
                });
                
                // Set timeout for loading
                const timeoutPromise = new Promise(resolve => {
                    setTimeout(() => {
                        if (!loadedData) {
                            statusElement.textContent = 'Still loading... This may take a moment.';
                        }
                        resolve(false);
                    }, 1500);
                });
                
                // Wait for data or timeout
                loadedData = await Promise.race([loadPromise, timeoutPromise]);
                
                // Wait for the actual data if timeout happened first
                if (!loadedData) {
                    loadedData = await loadPromise;
                }
                
                if (!loadedData) {
                    throw new Error('Failed to load players data');
                }
                
                // Extract clubs and populate UI
                extractClubs();
                
                // Reset pagination
                currentPage = 1;
                filteredPlayers = [...playersData];
                totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
                
                // Render players
                populatePlayersList();
                
                // Show data summary
                showStatusMessage(`Loaded ${playersData.length} players. Showing page 1 of ${totalPages}.`, true, 3000);
                
                // Hide loading status if it was success
                if (statusElement.textContent === 'Loading player data...' || 
                    statusElement.textContent === 'Still loading... This may take a moment.') {
                    statusElement.style.display = 'none';
                }
                
                // Return a resolved promise for chaining
                return Promise.resolve();
            } catch (error) {
                showStatusMessage(`Error: ${error.message}`, false);
                console.error('Error initializing admin panel:', error);
                return Promise.resolve(); // Still resolve to continue
            }
        }

        // Add LocalStorage change tracking system
        let pendingChanges = [];
        
        // Load pending changes from localStorage on init
        function loadPendingChanges() {
            const savedChanges = localStorage.getItem('pendingPlayerChanges');
            if (savedChanges) {
                try {
                    // If changes were recently pushed successfully, clear them
                    if (verifyGitHubPush()) {
                        localStorage.removeItem('pendingPlayerChanges');
                        pendingChanges = [];
                    } else {
                        pendingChanges = JSON.parse(savedChanges);
                    }
                    updatePendingChangesUI();
                } catch (error) {
                    console.error('Error loading pending changes:', error);
                    pendingChanges = [];
                }
            }
        }
        
        // Save pending changes to localStorage
        function savePendingChanges() {
            localStorage.setItem('pendingPlayerChanges', JSON.stringify(pendingChanges));
            updatePendingChangesUI();
        }
        
        // Update the UI to reflect pending changes
        function updatePendingChangesUI() {
            const container = document.getElementById('batch-save-container');
            const updatesContainer = document.getElementById('local-updates-container');
            const countElement = document.getElementById('pending-changes-count');
            const count = pendingChanges.length;
            
            if (count > 0) {
                container.style.display = 'flex';
                updatesContainer.style.display = 'block';
                countElement.textContent = count;
                document.getElementById('pending-changes-text').textContent = 
                    `You have ${count} pending change${count !== 1 ? 's' : ''} saved to localStorage.`;
                
                // Update the entries display
                updateEntriesDisplay();
            } else {
                container.style.display = 'none';
                updatesContainer.style.display = 'none';
            }
        }
        
        // Update the entries display
        function updateEntriesDisplay() {
            const entriesContainer = document.getElementById('update-entries');
            entriesContainer.innerHTML = '';
            
            pendingChanges.forEach((change, index) => {
                const entry = document.createElement('div');
                entry.className = 'update-entry';
                
                const timestamp = new Date(change.timestamp).toLocaleString();
                const playerName = change.playerData ? change.playerData.name : 'Unknown player';
                
                entry.innerHTML = `
                    <div>
                        <span class="update-timestamp">${timestamp}</span>
                        <span class="update-player">${playerName}</span>
                        <span class="update-type ${change.type}">${change.type.toUpperCase()}</span>
                    </div>
                    <div class="update-controls">
                        <button class="update-btn undo" data-index="${index}">Undo</button>
                        <button class="update-btn details" data-index="${index}">Details</button>
                    </div>
                `;
                
                entriesContainer.appendChild(entry);
            });
            
            // Add event listeners to undo and details buttons
            document.querySelectorAll('.update-btn.undo').forEach(button => {
                button.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    undoChange(index);
                });
            });
            
            document.querySelectorAll('.update-btn.details').forEach(button => {
                button.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    showChangeDetails(index);
                });
            });
        }
        
        // Add a change to the pending changes list
        function addPendingChange(type, playerData, previousData = null) {
            pendingChanges.push({
                type, // 'add', 'edit', or 'delete'
                playerData,
                previousData,
                timestamp: new Date().toISOString()
            });
            
            savePendingChanges();
        }
        
        // Undo a specific change
        function undoChange(index) {
            if (index < 0 || index >= pendingChanges.length) return;
            
            const change = pendingChanges[index];
            
            // Only confirm for changes that permanently affect data
            if (confirm(`Are you sure you want to undo this ${change.type} operation for ${change.playerData.name}?`)) {
                try {
                    switch (change.type) {
                        case 'add':
                            // Remove the added player
                            const addedPlayerIndex = playersData.findIndex(p => p.id === change.playerData.id);
                            if (addedPlayerIndex !== -1) {
                                playersData.splice(addedPlayerIndex, 1);
                            }
                            break;
                            
                        case 'edit':
                            // Restore previous data
                            if (change.previousData) {
                                const editedPlayerIndex = playersData.findIndex(p => p.id === change.playerData.id);
                                if (editedPlayerIndex !== -1) {
                                    playersData[editedPlayerIndex] = change.previousData;
                                }
                            }
                            break;
                            
                        case 'delete':
                            // Restore deleted player
                            if (change.previousData) {
                                playersData.push(change.previousData);
                            }
                            break;
                    }
                    
                    // Remove this change from pending changes
                    pendingChanges.splice(index, 1);
                    savePendingChanges();
                    
                    // Update UI
                    populatePlayersList(document.getElementById('player-search').value);
                    
                    // Show success message
                    showStatusMessage(`Undo successful for ${change.type} operation.`, true);
                } catch (error) {
                    console.error('Error undoing change:', error);
                    showStatusMessage(`Error undoing change: ${error.message}`, false);
                }
            }
        }
        
        // Show details for a specific change
        function showChangeDetails(index) {
            if (index < 0 || index >= pendingChanges.length) return;
            
            const change = pendingChanges[index];
            
            // Create a modal or dialog to display the details
            const detailsContainer = document.createElement('div');
            detailsContainer.style.position = 'fixed';
            detailsContainer.style.top = '50%';
            detailsContainer.style.left = '50%';
            detailsContainer.style.transform = 'translate(-50%, -50%)';
            detailsContainer.style.backgroundColor = '#282828';
            detailsContainer.style.borderRadius = '8px';
            detailsContainer.style.padding = '20px';
            detailsContainer.style.maxWidth = '90%';
            detailsContainer.style.maxHeight = '90%';
            detailsContainer.style.overflow = 'auto';
            detailsContainer.style.zIndex = '1000';
            detailsContainer.style.boxShadow = '0 0 20px rgba(0, 0, 0, 0.5)';
            
            const header = document.createElement('h3');
            header.textContent = `Change Details: ${change.type.toUpperCase()} - ${change.playerData.name}`;
            header.style.borderBottom = '1px solid #444';
            header.style.paddingBottom = '10px';
            header.style.marginBottom = '15px';
            
            const timestamp = document.createElement('p');
            timestamp.textContent = `Timestamp: ${new Date(change.timestamp).toLocaleString()}`;
            timestamp.style.color = '#aaa';
            timestamp.style.fontSize = '0.9em';
            
            const dataContainer = document.createElement('div');
            dataContainer.style.display = 'grid';
            dataContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
            dataContainer.style.gap = '20px';
            dataContainer.style.marginTop = '15px';
            
            // Helper function to create a field row
            function createFieldRow(label, currentValue, previousValue) {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.marginBottom = '8px';
                row.style.padding = '8px';
                row.style.backgroundColor = currentValue !== previousValue ? 'rgba(255, 193, 7, 0.1)' : 'transparent';
                row.style.borderRadius = '4px';
                
                const labelElement = document.createElement('div');
                labelElement.style.flex = '1';
                labelElement.style.fontWeight = 'bold';
                labelElement.style.color = '#aaa';
                labelElement.textContent = label;
                
                const valueElement = document.createElement('div');
                valueElement.style.flex = '2';
                valueElement.style.color = currentValue !== previousValue ? '#ffb700' : 'white';
                valueElement.textContent = currentValue || 'Not set';
                
                row.appendChild(labelElement);
                row.appendChild(valueElement);
                return row;
            }
            
            // Create sections for current and previous data
            const currentSection = document.createElement('div');
            currentSection.innerHTML = '<h4 style="margin-bottom: 15px; color: #4caf50;">Current Data</h4>';
            
            const previousSection = document.createElement('div');
            previousSection.innerHTML = '<h4 style="margin-bottom: 15px; color: #ff9800;">Previous Data</h4>';
            
            // Define fields to display and their labels
            const fields = [
                { key: 'name', label: 'Player Name' },
                { key: 'position', label: 'Position' },
                { key: 'club', label: 'Club' },
                { key: 'value', label: 'Value' },
                { key: 'star', label: 'Star Rating' },
                { key: 'level', label: 'Level' }
            ];
            
            // Add fields to both sections
            fields.forEach(field => {
                const currentValue = change.playerData[field.key];
                const previousValue = change.previousData ? change.previousData[field.key] : null;
                
                currentSection.appendChild(createFieldRow(field.label, currentValue, previousValue));
                if (change.previousData) {
                    previousSection.appendChild(createFieldRow(field.label, previousValue, previousValue));
                }
            });
            
            // Add stats section if available
            if (change.playerData.stats && change.playerData.stats.length > 0) {
                const statsHeader = document.createElement('h4');
                statsHeader.textContent = 'Player Stats';
                statsHeader.style.marginTop = '20px';
                statsHeader.style.marginBottom = '10px';
                statsHeader.style.gridColumn = '1 / -1';
                
                const statsTable = document.createElement('table');
                statsTable.style.width = '100%';
                statsTable.style.borderCollapse = 'collapse';
                statsTable.style.marginTop = '10px';
                statsTable.style.gridColumn = '1 / -1';
                
                // Create table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid #444;">Season</th>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid #444;">Team</th>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid #444;">Value</th>
                    </tr>
                `;
                statsTable.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                change.playerData.stats.forEach(stat => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td style="padding: 8px; border-bottom: 1px solid #333;">${stat.season || ''}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #333;">${stat.team || ''}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #333;">${stat.value || ''}</td>
                    `;
                    tbody.appendChild(tr);
                });
                statsTable.appendChild(tbody);
                
                dataContainer.appendChild(statsHeader);
                dataContainer.appendChild(statsTable);
            }
            
            // Add sections to data container
            if (change.previousData) {
                dataContainer.appendChild(previousSection);
            }
            dataContainer.appendChild(currentSection);
            
            // Add change type indicator
            const changeTypeIndicator = document.createElement('div');
            changeTypeIndicator.style.marginTop = '20px';
            changeTypeIndicator.style.padding = '10px';
            changeTypeIndicator.style.borderRadius = '4px';
            changeTypeIndicator.style.textAlign = 'center';
            changeTypeIndicator.style.fontWeight = 'bold';
            
            switch (change.type) {
                case 'add':
                    changeTypeIndicator.style.backgroundColor = 'rgba(46, 204, 113, 0.2)';
                    changeTypeIndicator.style.color = '#2ecc71';
                    changeTypeIndicator.textContent = 'New Player Added';
                    break;
                case 'edit':
                    changeTypeIndicator.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                    changeTypeIndicator.style.color = '#3498db';
                    changeTypeIndicator.textContent = 'Player Details Updated';
                    break;
                case 'delete':
                    changeTypeIndicator.style.backgroundColor = 'rgba(231, 76, 60, 0.2)';
                    changeTypeIndicator.style.color = '#e74c3c';
                    changeTypeIndicator.textContent = 'Player Deleted';
                    break;
            }
            
            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.marginTop = '20px';
            closeButton.style.padding = '8px 15px';
            closeButton.style.backgroundColor = '#4caf50';
            closeButton.style.color = 'white';
            closeButton.style.border = 'none';
            closeButton.style.borderRadius = '4px';
            closeButton.style.cursor = 'pointer';
            closeButton.onclick = function() {
                document.body.removeChild(detailsContainer);
                document.body.removeChild(overlay);
            };
            
            // Add overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            overlay.style.zIndex = '999';
            overlay.onclick = function() {
                document.body.removeChild(detailsContainer);
                document.body.removeChild(overlay);
            };
            
            // Assemble and add to document
            detailsContainer.appendChild(header);
            detailsContainer.appendChild(timestamp);
            detailsContainer.appendChild(changeTypeIndicator);
            detailsContainer.appendChild(dataContainer);
            detailsContainer.appendChild(closeButton);
            
            document.body.appendChild(overlay);
            document.body.appendChild(detailsContainer);
        }
        
        // Push all pending changes to GitHub
        async function pushAllChangesToGitHub() {
            if (pendingChanges.length === 0) {
                console.log('No pending changes to push');
                showStatusMessage('No pending changes to push', false);
                return;
            }
            
            console.log(`Attempting to push ${pendingChanges.length} changes to GitHub...`);
            
            // Show loading
            const pushButton = document.getElementById('push-to-github-btn');
            const originalText = pushButton.innerHTML;
            pushButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Pushing...';
            pushButton.disabled = true;
            
            try {
                // Initialize GitHub config if needed
                if (!githubConfig) {
                    console.log('Initializing GitHub config...');
                    initGitHubConfig();
                }
                
                if (!githubConfig.isConfigured()) {
                    throw new Error('GitHub is not configured. Please set up your GitHub token first.');
                }
                
                // Save to GitHub directly
                console.log('Calling saveToGitHub...');
                const success = await saveToGitHub();
                console.log('saveToGitHub result:', success);
                
                if (success) {
                    // Clear pending changes from localStorage
                    localStorage.removeItem('pendingPlayerChanges');
                    
                    // Clear the pending changes array
                    pendingChanges = [];
                    
                    // Update UI to hide pending changes elements
                    const batchSaveContainer = document.getElementById('batch-save-container');
                    const localUpdatesContainer = document.getElementById('local-updates-container');
                    if (batchSaveContainer) {
                        console.log('Hiding batch save container');
                        batchSaveContainer.style.display = 'none';
                    }
                    if (localUpdatesContainer) {
                        console.log('Hiding local updates container');
                        localUpdatesContainer.style.display = 'none';
                    }
                    
                    // Show success message
                    showStatusMessage('All changes successfully pushed to GitHub! The site will update in a few minutes.', true);
                    
                    // Store the last successful push timestamp
                    const timestamp = new Date().toISOString();
                    console.log('Storing successful push timestamp:', timestamp);
                    localStorage.setItem('lastGitHubPushTimestamp', timestamp);
                } else {
                    throw new Error('Failed to push changes to GitHub');
                }
            } catch (error) {
                console.error('Error pushing changes to GitHub:', error);
                showStatusMessage(`Error pushing to GitHub: ${error.message}`, false);
            } finally {
                // Restore button
                pushButton.innerHTML = originalText;
                pushButton.disabled = false;
            }
        }

        // Add a function to check if changes were actually pushed
        function verifyGitHubPush() {
            const lastPushTimestamp = localStorage.getItem('lastGitHubPushTimestamp');
            if (lastPushTimestamp) {
                const lastPush = new Date(lastPushTimestamp);
                const now = new Date();
                const timeDiff = now - lastPush;
                
                // If last push was less than 5 minutes ago, consider changes as pushed
                if (timeDiff < 300000) { // 5 minutes in milliseconds
                    return true;
                }
            }
            return false;
        }

        // Modify loadPendingChanges to check for recent pushes
        function loadPendingChanges() {
            const savedChanges = localStorage.getItem('pendingPlayerChanges');
            if (savedChanges) {
                try {
                    // If changes were recently pushed successfully, clear them
                    if (verifyGitHubPush()) {
                        localStorage.removeItem('pendingPlayerChanges');
                        pendingChanges = [];
                    } else {
                        pendingChanges = JSON.parse(savedChanges);
                    }
                    updatePendingChangesUI();
                } catch (error) {
                    console.error('Error loading pending changes:', error);
                    pendingChanges = [];
                }
            }
        }

        // Add a function to check GitHub status periodically
        function startGitHubStatusCheck() {
            // Check every minute
            setInterval(() => {
                if (pendingChanges.length > 0 && verifyGitHubPush()) {
                    // Clear pending changes if they were pushed
                    localStorage.removeItem('pendingPlayerChanges');
                    pendingChanges = [];
                    updatePendingChangesUI();
                }
            }, 60000); // Check every minute
        }

        // Update the document ready handler to start the status check
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Load pending changes
            loadPendingChanges();
            
            // Start GitHub status check
            startGitHubStatusCheck();
            
            // Add push to GitHub button event listener
            document.getElementById('push-to-github-btn').addEventListener('click', pushAllChangesToGitHub);
            
            // ... existing code ...
        });
        
        // Modify savePlayerChanges function to store changes in localStorage first
        async function savePlayerChanges() {
            // First give immediate UI feedback that save was clicked
            const saveBtn = document.getElementById('save-btn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            try {
                // Validate required fields
                const playerName = document.getElementById('player-name').value.trim();
                const playerValue = parseInt(document.getElementById('player-value').value);
                
                if (!playerName) {
                    throw new Error('Player name is required');
                }
                
                if (isNaN(playerValue) || playerValue < 1) {
                    throw new Error('Player value must be a positive number');
                }
                
                // Store previous data for undo if editing existing player
                const previousData = !isNewPlayer ? {...currentPlayer} : null;
                
                // Update current player object with form values immediately
                const updatedPlayer = {
                    ...currentPlayer,
                    name: playerName,
                    star: document.getElementById('player-star').value,
                    level: document.getElementById('player-level').value,
                    club: document.getElementById('player-club').value,
                    position: document.getElementById('player-position').value,
                    value: playerValue,
                    imagePath: document.getElementById('player-image-path').value
                };
                
                // Get stats with the correct structure
                const statsElements = document.querySelectorAll('.stat-item');
                updatedPlayer.stats = Array.from(statsElements).map(statElement => {
                    const season = statElement.querySelector('[data-stat-season]').value;
                    const team = statElement.querySelector('[data-stat-team]').value;
                    const value = statElement.querySelector('[data-stat-value]').value;
                    
                    return { 
                        season,
                        team,
                        value
                    };
                });
                
                // Update club logo using ClubManager
                const clubData = window.ClubManager.getClub(updatedPlayer.club);
                if (clubData) {
                    updatedPlayer.clubLogo = clubData.logo;
                }
                
                // Determine the change type
                const changeType = isNewPlayer ? 'add' : 'edit';
                
                // Update in memory immediately - don't wait for server
                if (isNewPlayer) {
                    // Find the highest existing ID and increment by 1
                    const maxId = Math.max(...playersData.map(p => p.id), 0);
                    updatedPlayer.id = maxId + 1;
                    playersData.push(updatedPlayer);
                    
                    // Add to filtered players if applicable
                    const searchTerm = document.getElementById('player-search').value.toLowerCase();
                    if (!searchTerm || updatedPlayer.name.toLowerCase().includes(searchTerm)) {
                        // Add to filtered players and re-sort
                        filteredPlayers.push(updatedPlayer);
                        
                        // Navigate to the page with the new player
                        currentPage = Math.ceil(filteredPlayers.length / playersPerPage);
                    }
                } else {
                    // Update existing player
                    const playerIndex = playersData.findIndex(p => Number(p.id) === Number(currentPlayer.id));
                    if (playerIndex !== -1) {
                        playersData[playerIndex] = updatedPlayer;
                        
                        // Update in filtered players if present
                        const filteredIndex = filteredPlayers.findIndex(p => Number(p.id) === Number(currentPlayer.id));
                        if (filteredIndex !== -1) {
                            filteredPlayers[filteredIndex] = updatedPlayer;
                        }
                    } else {
                        throw new Error('Player not found in the database');
                    }
                }
                
                // Add this change to pending changes
                addPendingChange(changeType, updatedPlayer, previousData);
                
                // Update current player reference and reset state
                currentPlayer = updatedPlayer;
                isNewPlayer = false;
                
                // Update players list to show changes immediately
                populatePlayersList(document.getElementById('player-search').value);
                
                // Reselect the current player in the list
                selectPlayer(currentPlayer.id);
                
                // Sync changes to manager data
                if (managerData) {
                    syncPlayerToManagerData(updatedPlayer);
                    console.log('Player data synced to manager data:', managerData);
                } else {
                    console.warn('Manager data not available. Cannot sync player data.');
                }
                
                // Show immediate success message
                showStatusMessage('Player saved to local storage. Use "Push All to GitHub" to save permanently.', true);
                
            } catch (error) {
                showStatusMessage(error.message, false);
                console.error('Error saving player changes:', error);
            } finally {
                // Always restore button state
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }
        
        // Update delete player function to add to pending changes
        async function deletePlayer() {
            if (!currentPlayer || isNewPlayer) return;
            
            if (!confirm(`Are you sure you want to delete ${currentPlayer.name}?`)) {
                return;
            }
            
            try {
                // Store player ID for later use
                const playerId = Number(currentPlayer.id);
                const playerName = currentPlayer.name;
                const playerPosition = currentPlayer.position;
                
                // Store a copy of the player data for potential undo
                const deletedPlayerData = {...currentPlayer};
                
                // Remove player from main array
                const playerIndex = playersData.findIndex(p => Number(p.id) === playerId);
                if (playerIndex !== -1) {
                    playersData.splice(playerIndex, 1);
                    
                    // Also remove from filtered players if present
                    const filteredIndex = filteredPlayers.findIndex(p => Number(p.id) === playerId);
                    if (filteredIndex !== -1) {
                        filteredPlayers.splice(filteredIndex, 1);
                    }
                    
                    // Add this change to pending changes
                    addPendingChange('delete', deletedPlayerData, deletedPlayerData);
                    
                    // Remove from manager data if present
                    if (managerData && managerData.managers) {
                        managerData.managers.forEach(manager => {
                            if (manager.squad && manager.squad.players) {
                                const squadIndex = manager.squad.players.findIndex(p => 
                                    p.name.toUpperCase() === playerName.toUpperCase() && 
                                    p.position === playerPosition
                                );
                                
                                if (squadIndex !== -1) {
                                    manager.squad.players.splice(squadIndex, 1);
                                    
                                    // Update player count
                                    manager.squad.total_players = manager.squad.players.length;
                                    
                                    // Recalculate club total value
                                    recalculateManagerTotalValue(manager);
                                    
                                    console.log(`Removed player "${playerName}" from ${manager.name}'s squad`);
                                }
                            }
                        });
                    }
                    
                    // Calculate new total pages
                    totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
                    
                    // Adjust current page if needed
                    if (currentPage > totalPages) {
                        currentPage = totalPages || 1;
                    }
                    
                    // Update players list with current search term
                    populatePlayersList(document.getElementById('player-search').value);
                    
                    // Reset editor
                    currentPlayer = null;
                    toggleEditorState(false);
                    
                    showStatusMessage('Player deleted and saved to local storage. Use "Push All to GitHub" to save permanently.', true);
                } else {
                    throw new Error('Player not found in the database');
                }
            } catch (error) {
                showStatusMessage(error.message, false);
                console.error('Error deleting player:', error);
            }
        }

        // Save a file to GitHub with cache-busting for Vercel
        async function saveFileToGitHub(data, filePath, commitMessage) {
            try {
                console.log(`Starting save for ${filePath}...`);
                
                // Get repository details
                const repoDetails = {
                    owner: githubConfig.getOwner(),
                    repo: githubConfig.getRepo(),
                    path: filePath,
                    branch: githubConfig.getBranch()
                };
                
                // Get the current file to get its SHA
                console.log('Fetching current file info...');
                const fileInfoResponse = await fetch(`https://api.github.com/repos/${repoDetails.owner}/${repoDetails.repo}/contents/${repoDetails.path}?ref=${repoDetails.branch}`, {
                    headers: {
                        'Authorization': `token ${githubConfig.getToken()}`
                    }
                });
                
                let currentSHA = '';
                let fileExists = true;
                
                if (fileInfoResponse.status === 404) {
                    console.log('File does not exist yet, will create it');
                    fileExists = false;
                } else if (!fileInfoResponse.ok) {
                    const errorData = await fileInfoResponse.json();
                    console.error('Error getting file info:', errorData);
                    throw new Error(`GitHub API error: ${errorData.message}`);
                } else {
                    const fileInfo = await fileInfoResponse.json();
                    currentSHA = fileInfo.sha;
                    console.log('Found existing file with SHA:', currentSHA);
                }
                
                // For JSON data, add a cache-busting timestamp if appropriate
                if (typeof data === 'object' && data !== null && !Array.isArray(data)) {
                    // Add a hidden timestamp field for cache busting
                    data._lastUpdated = new Date().toISOString();
                } else if (Array.isArray(data)) {
                    // For array data, we'll wrap it in an object with a timestamp
                    const wrappedData = {
                        data: data,
                        _lastUpdated: new Date().toISOString()
                    };
                    
                    // If the file is players.json, we need to maintain the original format
                    // Otherwise, wrap it for cache busting
                    if (filePath !== 'players.json') {
                        data = wrappedData;
                    }
                }
                
                // Prepare the content
                const jsonString = JSON.stringify(data, null, 2);
                const content = btoa(unescape(encodeURIComponent(jsonString)));
                
                // Prepare the commit
                const requestBody = {
                    message: `${commitMessage} - ${new Date().toISOString()}`,
                    content: content,
                    branch: repoDetails.branch
                };
                
                if (fileExists) {
                    requestBody.sha = currentSHA;
                }
                
                console.log(`Committing ${filePath}...`);
                const commitResponse = await fetch(`https://api.github.com/repos/${repoDetails.owner}/${repoDetails.repo}/contents/${repoDetails.path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${githubConfig.getToken()}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!commitResponse.ok) {
                    const errorData = await commitResponse.json();
                    console.error(`Failed to commit ${filePath}:`, errorData);
                    throw new Error(`Failed to commit ${filePath}: ${errorData.message}`);
                }
                
                console.log(`Successfully saved ${filePath}`);
                
                // If this is a successful save, trigger Vercel deployment if configured
                if (commitResponse.ok) {
                    triggerVercelDeployment();
                }
                
                return commitResponse;
                
            } catch (error) {
                console.error(`Error saving ${filePath}:`, error);
                throw error;
            }
        }
        
        // Function to trigger Vercel deployment and clear cache
        async function triggerVercelDeployment() {
            try {
                // Store deployment trigger time
                const triggerTime = new Date().toISOString();
                localStorage.setItem('lastVercelDeployTrigger', triggerTime);
                
                console.log('Attempting to trigger Vercel deployment...');
                
                // Set the default deploy hook
                const defaultDeployHook = 'https://api.vercel.com/v1/integrations/deploy/prj_zay0W2jm2U9RmCM9ujPjcYg8M9vq/OrjEvgJEbE';
                
                // Check if we have a Vercel deploy hook URL stored, otherwise use default
                let deployHookUrl = localStorage.getItem('vercelDeployHook');
                
                // If no hook is found in localStorage, use the default and store it
                if (!deployHookUrl) {
                    console.log('Using default Vercel deploy hook');
                    deployHookUrl = defaultDeployHook;
                    
                    // Save it to localStorage for future use
                    localStorage.setItem('vercelDeployHook', deployHookUrl);
                }
                
                if (deployHookUrl) {
                    console.log('Using Vercel deploy hook:', deployHookUrl);
                    
                    // Trigger deployment webhook
                    const response = await fetch(deployHookUrl, { method: 'POST' });
                    
                    if (response.ok) {
                        console.log('Vercel deployment triggered successfully');
                        const responseData = await response.json();
                        console.log('Deployment job created:', responseData);
                        showStatusMessage('Vercel deployment triggered. Site will update in a few minutes.', true, 5000);
                        
                        // Store successful deployment trigger
                        localStorage.setItem('vercelDeploymentStatus', 'triggered');
                        localStorage.setItem('vercelDeploymentTime', triggerTime);
                    } else {
                        console.error('Failed to trigger Vercel deployment', await response.text());
                    }
                } else {
                    console.log('No Vercel deploy hook URL configured. Skipping deployment trigger.');
                }
                
                // Also add cache busters to loaded files for immediate local use
                addCacheBustersToUrls();
                
            } catch (error) {
                console.error('Error triggering Vercel deployment:', error);
                // Don't throw, as this is optional functionality
            }
        }
        
        // Add cache busters to URLs for immediate local use
        function addCacheBustersToUrls() {
            try {
                console.log('Adding cache busters to loaded files...');
                
                // Generate a cache buster value based on current time
                const cacheBuster = Date.now();
                
                // Update localStorage to remember when we last busted cache
                localStorage.setItem('lastCacheBust', cacheBuster.toString());
                
                // For already loaded JSON files, we can reload them with cache busters
                // But we need to tell the user they might need to hard refresh
                showStatusMessage('Files updated. You may need to press Ctrl+F5 to see the latest changes.', true, 8000);
            } catch (error) {
                console.error('Error adding cache busters:', error);
            }
        }
        
        // Function to check if we can load from cache or need to refresh
        function shouldReloadData() {
            try {
                const lastCacheBust = localStorage.getItem('lastCacheBust');
                const lastDeployment = localStorage.getItem('vercelDeploymentTime');
                
                if (lastCacheBust && lastDeployment) {
                    // If we've busted cache since the last deployment, we're probably good
                    const cacheBustTime = parseInt(lastCacheBust);
                    const deployTime = new Date(lastDeployment).getTime();
                    
                    // If cache bust is more recent than deployment, we're good
                    if (cacheBustTime > deployTime) {
                        return false;
                    }
                }
                
                // By default, encourage reload if we're unsure
                return true;
            } catch (error) {
                console.error('Error checking reload status:', error);
                return true;
            }
        }
        
        // Add settings UI for Vercel deployment
        function addVercelSettingsUI() {
            try {
                // Check if settings UI already exists
                if (document.getElementById('vercel-settings-button')) {
                    return;
                }
                
                // Create settings button
                const settingsButton = document.createElement('button');
                settingsButton.id = 'vercel-settings-button';
                settingsButton.innerHTML = '<i class="fas fa-cog"></i> Vercel Settings';
                settingsButton.style.marginLeft = '10px';
                settingsButton.style.backgroundColor = '#0070f3';
                settingsButton.style.color = 'white';
                settingsButton.style.border = 'none';
                settingsButton.style.borderRadius = '4px';
                settingsButton.style.padding = '8px 12px';
                settingsButton.style.cursor = 'pointer';
                
                // Add click handler
                settingsButton.addEventListener('click', showVercelSettings);
                
                // Find a good place to add the button in the header
                const userInfo = document.querySelector('.user-info');
                if (userInfo) {
                    userInfo.appendChild(settingsButton);
                }
            } catch (error) {
                console.error('Error adding Vercel settings UI:', error);
            }
        }
        
        // Show Vercel settings dialog
        function showVercelSettings() {
            try {
                // Default deploy hook
                const defaultDeployHook = 'https://api.vercel.com/v1/integrations/deploy/prj_zay0W2jm2U9RmCM9ujPjcYg8M9vq/OrjEvgJEbE';
                
                // Create modal
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                modal.style.zIndex = '1000';
                modal.style.display = 'flex';
                modal.style.justifyContent = 'center';
                modal.style.alignItems = 'center';
                
                // Create modal content
                const content = document.createElement('div');
                content.style.backgroundColor = '#282828';
                content.style.borderRadius = '8px';
                content.style.padding = '20px';
                content.style.maxWidth = '600px';
                content.style.width = '90%';
                content.style.maxHeight = '90%';
                content.style.overflow = 'auto';
                
                // Title
                const title = document.createElement('h2');
                title.textContent = 'Vercel Deployment Settings';
                title.style.marginTop = '0';
                title.style.borderBottom = '1px solid #444';
                title.style.paddingBottom = '10px';
                
                // Deploy hook section
                const hookSection = document.createElement('div');
                hookSection.style.marginTop = '20px';
                
                const hookLabel = document.createElement('h3');
                hookLabel.textContent = 'Deploy Hook URL';
                
                const hookDescription = document.createElement('p');
                hookDescription.textContent = 'A deploy hook allows this admin panel to trigger a new Vercel deployment when changes are saved. This helps ensure your changes are visible immediately.';
                hookDescription.style.color = '#aaa';
                
                const hookInput = document.createElement('input');
                hookInput.type = 'text';
                hookInput.placeholder = 'https://api.vercel.com/v1/integrations/deploy/...';
                
                // Use the stored hook or default
                const storedHook = localStorage.getItem('vercelDeployHook');
                hookInput.value = storedHook || defaultDeployHook;
                
                hookInput.style.width = '100%';
                hookInput.style.padding = '10px';
                hookInput.style.backgroundColor = '#333';
                hookInput.style.border = '1px solid #444';
                hookInput.style.borderRadius = '4px';
                hookInput.style.color = 'white';
                hookInput.style.marginBottom = '10px';
                
                const hookHelpLink = document.createElement('a');
                hookHelpLink.href = 'https://vercel.com/docs/git/deploy-hooks';
                hookHelpLink.textContent = 'How to create a deploy hook in Vercel';
                hookHelpLink.target = '_blank';
                hookHelpLink.style.color = '#3498db';
                hookHelpLink.style.display = 'inline-block';
                hookHelpLink.style.marginBottom = '20px';
                
                // Test hook button
                const testButton = document.createElement('button');
                testButton.textContent = 'Test Deploy Hook';
                testButton.style.backgroundColor = '#0070f3';
                testButton.style.color = 'white';
                testButton.style.border = 'none';
                testButton.style.borderRadius = '4px';
                testButton.style.padding = '10px 15px';
                testButton.style.cursor = 'pointer';
                testButton.style.marginTop = '10px';
                
                testButton.addEventListener('click', async () => {
                    const hookUrl = hookInput.value.trim();
                    
                    if (!hookUrl) {
                        alert('Please enter a deploy hook URL first.');
                        return;
                    }
                    
                    testButton.textContent = 'Testing...';
                    testButton.disabled = true;
                    
                    try {
                        const response = await fetch(hookUrl, { method: 'POST' });
                        
                        if (response.ok) {
                            alert('Deploy hook test successful! Vercel deployment has been triggered.');
                            localStorage.setItem('vercelDeployHook', hookUrl);
                        } else {
                            const errorText = await response.text();
                            alert(`Deploy hook test failed: ${response.status} ${response.statusText}\n\n${errorText}`);
                        }
                    } catch (error) {
                        alert(`Error testing deploy hook: ${error.message}`);
                    } finally {
                        testButton.textContent = 'Test Deploy Hook';
                        testButton.disabled = false;
                    }
                });
                
                // Clear cache section
                const cacheSection = document.createElement('div');
                cacheSection.style.marginTop = '30px';
                cacheSection.style.borderTop = '1px solid #444';
                cacheSection.style.paddingTop = '20px';
                
                const cacheLabel = document.createElement('h3');
                cacheLabel.textContent = 'Clear Browser Cache';
                
                const cacheDescription = document.createElement('p');
                cacheDescription.textContent = 'If you\'re still seeing old data after pushing to GitHub, you may need to clear your browser cache.';
                cacheDescription.style.color = '#aaa';
                
                const clearCacheButton = document.createElement('button');
                clearCacheButton.textContent = 'Clear Local Cache';
                clearCacheButton.style.backgroundColor = '#e74c3c';
                clearCacheButton.style.color = 'white';
                clearCacheButton.style.border = 'none';
                clearCacheButton.style.borderRadius = '4px';
                clearCacheButton.style.padding = '10px 15px';
                clearCacheButton.style.cursor = 'pointer';
                
                clearCacheButton.addEventListener('click', () => {
                    if (confirm('This will reload the page and clear the local cache. Continue?')) {
                        // Add cache-busting parameter to current URL
                        const sep = window.location.href.indexOf('?') !== -1 ? '&' : '?';
                        const bustCache = `${sep}cache=${Date.now()}`;
                        window.location.href = window.location.href + bustCache;
                    }
                });
                
                // Save button
                const saveButton = document.createElement('button');
                saveButton.textContent = 'Save Settings';
                saveButton.style.backgroundColor = '#2ecc71';
                saveButton.style.color = 'white';
                saveButton.style.border = 'none';
                saveButton.style.borderRadius = '4px';
                saveButton.style.padding = '10px 15px';
                saveButton.style.cursor = 'pointer';
                saveButton.style.marginTop = '20px';
                saveButton.style.marginRight = '10px';
                
                saveButton.addEventListener('click', () => {
                    localStorage.setItem('vercelDeployHook', hookInput.value.trim());
                    alert('Settings saved!');
                    document.body.removeChild(modal);
                });
                
                // Close button
                const closeButton = document.createElement('button');
                closeButton.textContent = 'Close';
                closeButton.style.backgroundColor = '#7f8c8d';
                closeButton.style.color = 'white';
                closeButton.style.border = 'none';
                closeButton.style.borderRadius = '4px';
                closeButton.style.padding = '10px 15px';
                closeButton.style.cursor = 'pointer';
                closeButton.style.marginTop = '20px';
                
                closeButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                // Assemble the UI
                hookSection.appendChild(hookLabel);
                hookSection.appendChild(hookDescription);
                hookSection.appendChild(hookInput);
                hookSection.appendChild(hookHelpLink);
                hookSection.appendChild(document.createElement('br'));
                hookSection.appendChild(testButton);
                
                cacheSection.appendChild(cacheLabel);
                cacheSection.appendChild(cacheDescription);
                cacheSection.appendChild(clearCacheButton);
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.justifyContent = 'flex-end';
                buttonContainer.appendChild(saveButton);
                buttonContainer.appendChild(closeButton);
                
                content.appendChild(title);
                content.appendChild(hookSection);
                content.appendChild(cacheSection);
                content.appendChild(buttonContainer);
                
                modal.appendChild(content);
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error showing Vercel settings:', error);
            }
        }
        
        // Update document ready handler to initialize Vercel settings
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Initialize Vercel settings UI
            addVercelSettingsUI();
            
            // Add cache busting if needed
            if (shouldReloadData()) {
                addCacheBustersToUrls();
            }
            
            // ... existing code ...
        });
    </script>

    <!-- Performance optimization JS -->
    <script>
        // Immediately executed critical JS
        document.addEventListener('DOMContentLoaded', function() {
            // Load the video after page content
            setTimeout(function() {
                const video = document.querySelector('.video-bg');
                if (video && video.dataset.src) {
                    const source = document.createElement('source');
                    source.src = video.dataset.src;
                    source.type = 'video/mp4';
                    video.appendChild(source);
                    video.load();
                    video.play().catch(e => console.log('Autoplay prevented:', e));
                }
            }, 1000);
            
            // Set fade out for preloader
            window.addEventListener('load', function() {
                const preloader = document.querySelector('.preloader');
                if (preloader) {
                    setTimeout(function() {
                        preloader.style.opacity = '0';
                        setTimeout(function() {
                            preloader.style.display = 'none';
                        }, 500);
                    }, 500);
                }
            });
        });
    </script>
    <script src="js/remove-conflicting-styles.js"></script>
    
    <script src="js/background-fix.js"></script>
    <script src="js/background-mobile-scroll.js"></script>
    <script src="js/script.js"></script>
    <script src="js/fix-scroll.js"></script>
</body>
</html> 
    