<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Players.json Validator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }
        .container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-left: 4px solid #4ecca3;
        }
        h1 {
            color: #4ecca3;
            margin-top: 0;
        }
        button {
            background-color: #4ecca3;
            color: #121212;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3db893;
        }
        .loading {
            display: none;
            margin-top: 20px;
            color: #4ecca3;
        }
        .stats {
            margin-top: 15px;
            padding: 10px;
            background-color: #252525;
            border-radius: 4px;
        }
        .results-container {
            display: none;
            margin-top: 20px;
        }
        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-button {
            background-color: #333;
            color: #e0e0e0;
            border: none;
            padding: 8px 15px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
        }
        .tab-button.active {
            background-color: #4ecca3;
            color: #121212;
        }
        .tab-content {
            background-color: #252525;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
        }
        .count-badge {
            display: inline-block;
            background-color: #ff5722;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
            font-weight: bold;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        .issue-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #4ecca3;
            background-color: #2a2a2a;
        }
        .critical {
            border-left-color: #ff5722;
        }
        .warning {
            border-left-color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Players.json Validator</h1>
        <p>This tool checks for all types of mistakes and issues in your players.json file.</p>
        
        <button id="checkIssues">Check For Issues</button>
        <button id="downloadReport" disabled>Download Report</button>
        
        <div id="loading" class="loading">Analyzing players.json... This may take a moment.</div>
        
        <div id="stats" class="stats" style="display: none;">
            <h3>Issues Found Summary:</h3>
            <div id="summaryStats"></div>
        </div>
        
        <div id="resultsContainer" class="results-container">
            <div class="tab-buttons" id="tabButtons"></div>
            <div class="tab-content" id="tabContent"></div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const checkIssuesBtn = document.getElementById('checkIssues');
        const downloadBtn = document.getElementById('downloadReport');
        const loadingDiv = document.getElementById('loading');
        const statsDiv = document.getElementById('stats');
        const summaryStatsDiv = document.getElementById('summaryStats');
        const resultsContainer = document.getElementById('resultsContainer');
        const tabButtons = document.getElementById('tabButtons');
        const tabContent = document.getElementById('tabContent');
        
        // Store results for download
        let reportText = '';
        let validationResults = {};
        
        // Issue types and their descriptions
        const issueTypes = {
            duplicateIds: { name: 'Duplicate IDs', critical: true },
            missingRequiredFields: { name: 'Missing Required Fields', critical: true },
            duplicateNames: { name: 'Duplicate Names', critical: false },
            similarNames: { name: 'Similar Names', critical: false },
            invalidValues: { name: 'Invalid Values', critical: false },
            statIssues: { name: 'Stat Issues', critical: false },
            incompleteData: { name: 'Incomplete Data', critical: false },
            inconsistentData: { name: 'Inconsistent Data', critical: false }
        };
        
        // Add event listeners
        checkIssuesBtn.addEventListener('click', validatePlayersJson);
        downloadBtn.addEventListener('click', downloadReport);
        
        // Function to normalize names for comparison
        function normalizeName(name) {
            if (!name) return '';
            return name.trim().toUpperCase()
                .replace(/\s+/g, ' ')
                .replace(/[^\w\s]/g, '');
        }
        
        // Helper function to check if names are similar
        function areSimilarNames(name1, name2) {
            if (name1 === name2) return false; // Already caught as exact duplicates
            
            // Simple similarity algorithm
            let similarity = 0;
            const longer = name1.length > name2.length ? name1 : name2;
            const shorter = name1.length > name2.length ? name2 : name1;
            
            if (shorter.length === 0) return false;
            
            // Check for substring
            if (longer.includes(shorter)) return true;
            
            // Check common characters
            for (let i = 0; i < shorter.length; i++) {
                if (longer.includes(shorter[i])) {
                    similarity++;
                }
            }
            
            return similarity / shorter.length > 0.8;
        }
        
        // Helper function to find the latest stat by season
        function findLatestStat(stats) {
            if (!stats || stats.length === 0) return null;
            
            return stats.reduce((latest, current) => {
                if (!latest.season) return current;
                if (!current.season) return latest;
                
                const [latestStartYear] = latest.season.split('/').map(year => parseInt(year));
                const [currentStartYear] = current.season.split('/').map(year => parseInt(year));
                
                return currentStartYear > latestStartYear ? current : latest;
            }, stats[0]);
        }
        
        // Helper function to check if teams might be related
        function areRelatedTeams(team1, team2) {
            return team1.includes(team2) || team2.includes(team1);
        }
        
        // Function to validate players.json
        async function validatePlayersJson() {
            // Reset UI
            loadingDiv.style.display = 'block';
            statsDiv.style.display = 'none';
            resultsContainer.style.display = 'none';
            tabButtons.innerHTML = '';
            tabContent.innerHTML = '';
            downloadBtn.disabled = true;
            
            try {
                // Fetch players.json
                const response = await fetch('players.json');
                const players = await response.json();
                
                // Initialize results object
                const results = {
                    duplicateIds: [],
                    duplicateNames: [],
                    similarNames: [],
                    missingRequiredFields: [],
                    invalidValues: [],
                    statIssues: [],
                    incompleteData: [],
                    inconsistentData: []
                };
                
                // Track IDs and names for duplicate detection
                const ids = new Map();
                const names = new Map();
                const normalizedNames = new Map();
                
                // Required fields
                const requiredPlayerFields = ['id', 'name', 'position'];
                const requiredStatFields = ['season', 'team'];
                
                // Valid positions
                const validPositions = ['GK', 'CB', 'SW', 'FB', 'WB', 'DM', 'CM', 'WM', 'AM', 'SS', 'CF'];
                
                // Process each player
                players.forEach((player, index) => {
                    // Check for missing required fields
                    requiredPlayerFields.forEach(field => {
                        if (!player[field] && player[field] !== 0) {
                            results.missingRequiredFields.push({
                                id: player.id || `Unknown (index ${index})`,
                                name: player.name || `Unknown (index ${index})`,
                                issue: `Missing required field: ${field}`
                            });
                        }
                    });
                    
                    if (player.id !== undefined) {
                        // Check for duplicate IDs
                        if (ids.has(player.id)) {
                            results.duplicateIds.push({
                                id: player.id,
                                name: player.name || 'Unknown',
                                duplicateWith: ids.get(player.id)
                            });
                        } else {
                            ids.set(player.id, player.name || 'Unknown');
                        }
                    }
                    
                    if (player.name) {
                        // Check for duplicate names
                        if (names.has(player.name)) {
                            results.duplicateNames.push({
                                id: player.id || `Unknown (index ${index})`,
                                name: player.name,
                                duplicateWith: names.get(player.name)
                            });
                        } else {
                            names.set(player.name, player.id || `Unknown (index ${index})`);
                        }
                        
                        // Check for similar names
                        const normalizedName = normalizeName(player.name);
                        for (const [existingName, existingId] of normalizedNames.entries()) {
                            if (existingName !== normalizedName && areSimilarNames(existingName, normalizedName)) {
                                const existingPlayer = players.find(p => String(p.id) === String(existingId) || 
                                                        (typeof existingId === 'string' && existingId.includes('index') && 
                                                         parseInt(existingId.match(/\d+/)[0]) === players.indexOf(p)));
                                const existingPlayerName = existingPlayer ? existingPlayer.name : 'Unknown';
                                
                                results.similarNames.push({
                                    id: player.id || `Unknown (index ${index})`,
                                    name: player.name,
                                    similarTo: existingPlayerName,
                                    similarToId: existingId
                                });
                            }
                        }
                        normalizedNames.set(normalizedName, player.id || `Unknown (index ${index})`);
                    }
                    
                    // Check valid position
                    if (player.position && !validPositions.includes(player.position)) {
                        results.invalidValues.push({
                            id: player.id || `Unknown (index ${index})`,
                            name: player.name || 'Unknown',
                            issue: `Invalid position: ${player.position}. Valid positions are: ${validPositions.join(', ')}`
                        });
                    }
                    
                    // Check for incomplete data
                    if (!player.position || !player.level || player.value === undefined) {
                        results.incompleteData.push({
                            id: player.id || `Unknown (index ${index})`,
                            name: player.name || 'Unknown',
                            issue: `Incomplete player data. Missing: ${!player.position ? 'position, ' : ''}${!player.level ? 'level, ' : ''}${player.value === undefined ? 'value' : ''}`
                        });
                    }
                    
                    // Check stats array
                    if (!player.stats) {
                        results.statIssues.push({
                            id: player.id || `Unknown (index ${index})`,
                            name: player.name || 'Unknown',
                            issue: 'Missing stats array'
                        });
                    } else if (!Array.isArray(player.stats)) {
                        results.statIssues.push({
                            id: player.id || `Unknown (index ${index})`,
                            name: player.name || 'Unknown',
                            issue: 'Stats is not an array'
                        });
                    } else if (player.stats.length === 0) {
                        results.statIssues.push({
                            id: player.id || `Unknown (index ${index})`,
                            name: player.name || 'Unknown',
                            issue: 'Empty stats array'
                        });
                    } else {
                        // Check for season issues
                        const seasons = new Set();
                        
                        player.stats.forEach(stat => {
                            // Check required stat fields
                            requiredStatFields.forEach(field => {
                                if (!stat[field] && stat[field] !== 0) {
                                    results.statIssues.push({
                                        id: player.id || `Unknown (index ${index})`,
                                        name: player.name || 'Unknown',
                                        issue: `Stat missing required field: ${field}`
                                    });
                                }
                            });
                            
                            // Check season format
                            if (stat.season) {
                                if (!stat.season.includes('/')) {
                                    results.statIssues.push({
                                        id: player.id || `Unknown (index ${index})`,
                                        name: player.name || 'Unknown',
                                        issue: `Invalid season format: ${stat.season}`
                                    });
                                } else {
                                    const [startYear, endYear] = stat.season.split('/').map(year => parseInt(year));
                                    if (isNaN(startYear) || isNaN(endYear)) {
                                        results.statIssues.push({
                                            id: player.id || `Unknown (index ${index})`,
                                            name: player.name || 'Unknown',
                                            issue: `Invalid season year format: ${stat.season}`
                                        });
                                    } else if (endYear <= startYear) {
                                        results.statIssues.push({
                                            id: player.id || `Unknown (index ${index})`,
                                            name: player.name || 'Unknown',
                                            issue: `Season end year (${endYear}) should be greater than start year (${startYear}): ${stat.season}`
                                        });
                                    }
                                    
                                    // Check for duplicate seasons
                                    if (seasons.has(stat.season)) {
                                        results.statIssues.push({
                                            id: player.id || `Unknown (index ${index})`,
                                            name: player.name || 'Unknown',
                                            issue: `Duplicate season: ${stat.season}`
                                        });
                                    }
                                    seasons.add(stat.season);
                                }
                            }
                            
                            // Check for negative values
                            ['goals', 'apps', 'assists', 'yellows', 'reds'].forEach(statField => {
                                if (stat[statField] !== undefined && (typeof stat[statField] !== 'number' || stat[statField] < 0)) {
                                    results.invalidValues.push({
                                        id: player.id || `Unknown (index ${index})`,
                                        name: player.name || 'Unknown',
                                        issue: `Invalid ${statField} value: ${stat[statField]}`
                                    });
                                }
                            });
                        });
                    }
                    
                    // Check for club/team inconsistency
                    if (player.club && player.stats && player.stats.length > 0) {
                        const latestStat = findLatestStat(player.stats);
                        if (latestStat && latestStat.team && player.club !== "FREE AGENT" && player.club !== "FREE AGENTP") {
                            // Check if current club matches the latest stat team
                            const clubNormalized = normalizeName(player.club);
                            const teamNormalized = normalizeName(latestStat.team);
                            
                            if (clubNormalized !== teamNormalized && !areRelatedTeams(clubNormalized, teamNormalized)) {
                                results.inconsistentData.push({
                                    id: player.id || `Unknown (index ${index})`,
                                    name: player.name || 'Unknown',
                                    issue: `Current club (${player.club}) doesn't match latest stat team (${latestStat.team}) for season ${latestStat.season}`
                                });
                            }
                        }
                    }
                });
                
                // Store results for display and download
                validationResults = results;
                reportText = generateReport(results, players.length);
                
                // Display results
                displayResults(results, players.length);
                
                // Enable download button
                downloadBtn.disabled = false;
            } catch (error) {
                console.error('Error processing players.json:', error);
                tabContent.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            } finally {
                loadingDiv.style.display = 'none';
            }
        }
        
        // Function to generate report text
        function generateReport(results, totalPlayers) {
            let report = `PLAYERS.JSON VALIDATION REPORT\n`;
            report += `================================\n\n`;
            report += `Total players analyzed: ${totalPlayers}\n\n`;
            
            // Summary of issues
            report += `SUMMARY OF ISSUES\n`;
            report += `-----------------\n`;
            report += `- Critical Issues:\n`;
            report += `  - Duplicate IDs: ${results.duplicateIds.length}\n`;
            report += `  - Missing required fields: ${results.missingRequiredFields.length}\n\n`;
            
            report += `- Data Quality Issues:\n`;
            report += `  - Duplicate names: ${results.duplicateNames.length}\n`;
            report += `  - Similar names (potential duplicates): ${results.similarNames.length}\n`;
            report += `  - Invalid values: ${results.invalidValues.length}\n`;
            report += `  - Stat issues: ${results.statIssues.length}\n`;
            report += `  - Incomplete data: ${results.incompleteData.length}\n`;
            report += `  - Inconsistent data: ${results.inconsistentData.length}\n\n`;
            
            // Detailed reports for each issue type
            if (results.duplicateIds.length > 0) {
                report += `DUPLICATE IDs (CRITICAL)\n`;
                report += `----------------------\n`;
                results.duplicateIds.forEach(issue => {
                    report += `- ID ${issue.id}: "${issue.name}" duplicates with "${issue.duplicateWith}"\n`;
                });
                report += `\n`;
            }
            
            if (results.missingRequiredFields.length > 0) {
                report += `MISSING REQUIRED FIELDS (CRITICAL)\n`;
                report += `--------------------------------\n`;
                results.missingRequiredFields.forEach(issue => {
                    report += `- ${issue.name} (ID: ${issue.id}): ${issue.issue}\n`;
                });
                report += `\n`;
            }
            
            if (results.duplicateNames.length > 0) {
                report += `DUPLICATE NAMES\n`;
                report += `--------------\n`;
                results.duplicateNames.forEach(issue => {
                    report += `- "${issue.name}" (ID: ${issue.id}) duplicates with player ID: ${issue.duplicateWith}\n`;
                });
                report += `\n`;
            }
            
            if (results.similarNames.length > 0) {
                report += `SIMILAR NAMES (POTENTIAL DUPLICATES)\n`;
                report += `----------------------------------\n`;
                results.similarNames.forEach(issue => {
                    report += `- "${issue.name}" (ID: ${issue.id}) is similar to "${issue.similarTo}" (ID: ${issue.similarToId})\n`;
                });
                report += `\n`;
            }
            
            if (results.invalidValues.length > 0) {
                report += `INVALID VALUES\n`;
                report += `-------------\n`;
                results.invalidValues.forEach(issue => {
                    report += `- ${issue.name} (ID: ${issue.id}): ${issue.issue}\n`;
                });
                report += `\n`;
            }
            
            if (results.statIssues.length > 0) {
                report += `STAT ISSUES\n`;
                report += `-----------\n`;
                results.statIssues.forEach(issue => {
                    report += `- ${issue.name} (ID: ${issue.id}): ${issue.issue}\n`;
                });
                report += `\n`;
            }
            
            if (results.incompleteData.length > 0) {
                report += `INCOMPLETE DATA\n`;
                report += `--------------\n`;
                results.incompleteData.forEach(issue => {
                    report += `- ${issue.name} (ID: ${issue.id}): ${issue.issue}\n`;
                });
                report += `\n`;
            }
            
            if (results.inconsistentData.length > 0) {
                report += `INCONSISTENT DATA\n`;
                report += `----------------\n`;
                results.inconsistentData.forEach(issue => {
                    report += `- ${issue.name} (ID: ${issue.id}): ${issue.issue}\n`;
                });
                report += `\n`;
            }
            
            report += `End of report. Generated on ${new Date().toLocaleString()}\n`;
            
            return report;
        }
        
        // Function to display results on the page
        function displayResults(results, totalPlayers) {
            // Show results container
            resultsContainer.style.display = 'block';
            
            // Update summary stats
            let summaryHTML = `<p>Total players analyzed: <strong>${totalPlayers}</strong></p>`;
            summaryHTML += '<h4>Critical Issues:</h4><ul>';
            for (const type in results) {
                if (issueTypes[type] && issueTypes[type].critical) {
                    summaryHTML += `<li>${issueTypes[type].name}: <strong>${results[type].length}</strong></li>`;
                }
            }
            summaryHTML += '</ul><h4>Data Quality Issues:</h4><ul>';
            for (const type in results) {
                if (issueTypes[type] && !issueTypes[type].critical) {
                    summaryHTML += `<li>${issueTypes[type].name}: <strong>${results[type].length}</strong></li>`;
                }
            }
            summaryHTML += '</ul>';
            summaryStatsDiv.innerHTML = summaryHTML;
            statsDiv.style.display = 'block';
            
            // Create tabs for each issue type
            let hasIssues = false;
            
            // Add all issues tab first
            const allButton = document.createElement('button');
            allButton.className = 'tab-button active';
            allButton.dataset.tab = 'all';
            
            let totalIssues = 0;
            for (const type in results) {
                totalIssues += results[type].length;
            }
            
            allButton.innerHTML = `All Issues <span class="count-badge">${totalIssues}</span>`;
            allButton.addEventListener('click', () => switchTab('all'));
            tabButtons.appendChild(allButton);
            
            // Create all issues panel
            const allPanel = document.createElement('div');
            allPanel.className = 'tab-panel active';
            allPanel.id = 'tab-all';
            
            let allIssuesHTML = '';
            if (totalIssues > 0) {
                for (const type in results) {
                    if (results[type].length > 0) {
                        hasIssues = true;
                        
                        allIssuesHTML += `<h3>${issueTypes[type].name} (${results[type].length})</h3>`;
                        results[type].forEach(issue => {
                            const criticalClass = issueTypes[type].critical ? 'critical' : '';
                            allIssuesHTML += `<div class="issue-entry ${criticalClass}">`;
                            if (type === 'duplicateIds') {
                                allIssuesHTML += `ID ${issue.id}: "${issue.name}" duplicates with "${issue.duplicateWith}"`;
                            } else if (type === 'duplicateNames') {
                                allIssuesHTML += `"${issue.name}" (ID: ${issue.id}) duplicates with player ID: ${issue.duplicateWith}`;
                            } else if (type === 'similarNames') {
                                allIssuesHTML += `"${issue.name}" (ID: ${issue.id}) is similar to "${issue.similarTo}" (ID: ${issue.similarToId})`;
                            } else {
                                allIssuesHTML += `${issue.name} (ID: ${issue.id}): ${issue.issue}`;
                            }
                            allIssuesHTML += `</div>`;
                        });
                    }
                }
            } else {
                allIssuesHTML = '<p>No issues found! Your players.json file looks good.</p>';
            }
            
            allPanel.innerHTML = allIssuesHTML;
            tabContent.appendChild(allPanel);
            
            // Create individual issue type tabs
            for (const type in results) {
                if (results[type].length > 0) {
                    // Create tab button
                    const button = document.createElement('button');
                    button.className = 'tab-button';
                    button.dataset.tab = type;
                    button.innerHTML = `${issueTypes[type].name} <span class="count-badge">${results[type].length}</span>`;
                    button.addEventListener('click', () => switchTab(type));
                    tabButtons.appendChild(button);
                    
                    // Create tab panel
                    const panel = document.createElement('div');
                    panel.className = 'tab-panel';
                    panel.id = `tab-${type}`;
                    
                    let issuesHTML = '';
                    results[type].forEach(issue => {
                        const criticalClass = issueTypes[type].critical ? 'critical' : '';
                        issuesHTML += `<div class="issue-entry ${criticalClass}">`;
                        if (type === 'duplicateIds') {
                            issuesHTML += `ID ${issue.id}: "${issue.name}" duplicates with "${issue.duplicateWith}"`;
                        } else if (type === 'duplicateNames') {
                            issuesHTML += `"${issue.name}" (ID: ${issue.id}) duplicates with player ID: ${issue.duplicateWith}`;
                        } else if (type === 'similarNames') {
                            issuesHTML += `"${issue.name}" (ID: ${issue.id}) is similar to "${issue.similarTo}" (ID: ${issue.similarToId})`;
                        } else {
                            issuesHTML += `${issue.name} (ID: ${issue.id}): ${issue.issue}`;
                        }
                        issuesHTML += `</div>`;
                    });
                    
                    panel.innerHTML = issuesHTML;
                    tabContent.appendChild(panel);
                }
            }
        }
        
        // Function to switch tabs
        function switchTab(tabId) {
            // Update active button
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
            
            // Update active panel
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            const activePanel = document.getElementById(`tab-${tabId}`);
            if (activePanel) {
                activePanel.classList.add('active');
            }
        }
        
        // Function to download the report
        function downloadReport() {
            const blob = new Blob([reportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'players_json_issues.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html> 